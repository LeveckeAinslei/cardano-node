-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Shelley Ledger Executable Model
--   
--   Shelley Ledger Executable Model
@package cardano-ledger-shelley
@version 1.7.0.0

module Cardano.Ledger.Chain
data ChainChecksPParams
ChainChecksPParams :: Natural -> Natural -> ProtVer -> ChainChecksPParams
[ccMaxBHSize] :: ChainChecksPParams -> Natural
[ccMaxBBSize] :: ChainChecksPParams -> Natural
[ccProtocolVersion] :: ChainChecksPParams -> ProtVer
data ChainPredicateFailure
HeaderSizeTooLargeCHAIN :: !Natural -> !Natural -> ChainPredicateFailure
BlockSizeTooLargeCHAIN :: !Natural -> !Natural -> ChainPredicateFailure
ObsoleteNodeCHAIN :: !Version -> !Version -> ChainPredicateFailure
pparamsToChainChecksPParams :: EraPParams era => PParams era -> ChainChecksPParams
chainChecks :: MonadError ChainPredicateFailure m => Version -> ChainChecksPParams -> BHeaderView c -> m ()
instance NoThunks.Class.NoThunks Cardano.Ledger.Chain.ChainChecksPParams
instance GHC.Generics.Generic Cardano.Ledger.Chain.ChainChecksPParams
instance GHC.Classes.Eq Cardano.Ledger.Chain.ChainChecksPParams
instance GHC.Show.Show Cardano.Ledger.Chain.ChainChecksPParams
instance GHC.Classes.Ord Cardano.Ledger.Chain.ChainPredicateFailure
instance GHC.Classes.Eq Cardano.Ledger.Chain.ChainPredicateFailure
instance GHC.Show.Show Cardano.Ledger.Chain.ChainPredicateFailure
instance GHC.Generics.Generic Cardano.Ledger.Chain.ChainPredicateFailure
instance NoThunks.Class.NoThunks Cardano.Ledger.Chain.ChainPredicateFailure


-- | <i>Deprecated: Use 'import Cardano.Ledger.Keys.Bootstrap' instead</i>
module Cardano.Ledger.Shelley.Address.Bootstrap


-- | <i>Deprecated: Use 'import Cardano.Ledger.EpochBoundary' instead</i>
module Cardano.Ledger.Shelley.EpochBoundary

module Cardano.Ledger.Shelley.HardForks
aggregatedRewards :: ProtVer -> Bool

-- | Starting with protocol version 5, the MIR certs will also be able to
--   transfer funds between the reserves and the treasury. Additionally,
--   the semantics for the pervious functionality will change a bit. Before
--   version 5 redundancies in the instantaneous reward mapping were
--   handled by overriding. Now they are handled by adding the values and
--   allowing for negatives updates, provided the sum for each key remains
--   positive.
allowMIRTransfer :: ProtVer -> Bool

-- | Starting with protocol version 5, we will validate the network ID for
--   the reward account listed in stake pool registration certificates.
validatePoolRewardAccountNetID :: ProtVer -> Bool

-- | Starting with protocol version 7, the UTXO rule predicate failure
--   MissingScriptWitnessesUTXOW will not be used for extraneous scripts
missingScriptsSymmetricDifference :: ProtVer -> Bool

-- | Starting with protocol version 7, the reward calculation no longer
--   filters out unregistered stake addresses at the moment the calculation
--   begins. See the Shelley Ledger Errata 17.2.
forgoRewardPrefilter :: ProtVer -> Bool

-- | Starting with protocol version 9, we translate the upper bound of
--   validity interval correctly for Plutus scripts.
--   
--   TODO - After mainnet has successfully moved to protocol version 9, we
--   can check to see if the semantic difference here has even been
--   exercised. (We probably also need to check preprod and potentially
--   preview.) If it has not been exercised by version 9, we can safely
--   remove this check and always use the correct semantics (which cleans
--   up the code).
translateUpperBoundForPlutusScripts :: ProtVer -> Bool

-- | Starting with protocol version 9, we no longer resolve pointer
--   addresses.
forgoPointerAddressResolution :: ProtVer -> Bool


-- | <i>Deprecated: Use 'import Cardano.Ledger.Orphans' instead</i>
module Cardano.Ledger.Shelley.Orphans


-- | This module contains just the type of protocol parameters.
module Cardano.Ledger.Shelley.PParams
emptyShelleyPParams :: forall era. Era era => ShelleyPParams Identity era
emptyShelleyPParamsUpdate :: ShelleyPParams StrictMaybe era

-- | Protocol parameters.
data ShelleyPParams f era
ShelleyPParams :: !HKD f Coin -> !HKD f Coin -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Coin -> !HKD f Coin -> !HKD f EpochNo -> !HKD f Natural -> !HKD f NonNegativeInterval -> !HKD f UnitInterval -> !HKD f UnitInterval -> !HKD f UnitInterval -> !HKD f Nonce -> !HKD f ProtVer -> !HKD f Coin -> !HKD f Coin -> ShelleyPParams f era

-- | The linear factor for the minimum fee calculation
[sppMinFeeA] :: ShelleyPParams f era -> !HKD f Coin

-- | The constant factor for the minimum fee calculation
[sppMinFeeB] :: ShelleyPParams f era -> !HKD f Coin

-- | Maximal block body size
[sppMaxBBSize] :: ShelleyPParams f era -> !HKD f Natural

-- | Maximal transaction size
[sppMaxTxSize] :: ShelleyPParams f era -> !HKD f Natural

-- | Maximal block header size
[sppMaxBHSize] :: ShelleyPParams f era -> !HKD f Natural

-- | The amount of a key registration deposit
[sppKeyDeposit] :: ShelleyPParams f era -> !HKD f Coin

-- | The amount of a pool registration deposit
[sppPoolDeposit] :: ShelleyPParams f era -> !HKD f Coin

-- | epoch bound on pool retirement
[sppEMax] :: ShelleyPParams f era -> !HKD f EpochNo

-- | Desired number of pools
[sppNOpt] :: ShelleyPParams f era -> !HKD f Natural

-- | Pool influence
[sppA0] :: ShelleyPParams f era -> !HKD f NonNegativeInterval

-- | Monetary expansion
[sppRho] :: ShelleyPParams f era -> !HKD f UnitInterval

-- | Treasury expansion
[sppTau] :: ShelleyPParams f era -> !HKD f UnitInterval

-- | Decentralization parameter
[sppD] :: ShelleyPParams f era -> !HKD f UnitInterval

-- | Extra entropy
[sppExtraEntropy] :: ShelleyPParams f era -> !HKD f Nonce

-- | Protocol version
[sppProtocolVersion] :: ShelleyPParams f era -> !HKD f ProtVer

-- | Minimum UTxO value
[sppMinUTxOValue] :: ShelleyPParams f era -> !HKD f Coin

-- | Minimum Stake Pool Cost
[sppMinPoolCost] :: ShelleyPParams f era -> !HKD f Coin
emptyPParams :: EraPParams era => PParams era
type family HKD (f :: Type -> Type) a
data PPUpdateEnv era
PPUpdateEnv :: SlotNo -> GenDelegs era -> PPUpdateEnv era

-- | Update operation for protocol parameters structure <tt>PParams</tt>
newtype ProposedPPUpdates era
ProposedPPUpdates :: Map (KeyHash 'Genesis (EraCrypto era)) (PParamsUpdate era) -> ProposedPPUpdates era
emptyPPPUpdates :: ProposedPPUpdates era

-- | Update Proposal
data Update era
Update :: !ProposedPPUpdates era -> !EpochNo -> Update era
pvCanFollow :: ProtVer -> StrictMaybe ProtVer -> Bool

-- | These are the fields that are common across all eras
shelleyCommonPParamsHKDPairs :: forall f era. (HKDFunctor f, EraPParams era) => Proxy f -> PParamsHKD f era -> [(Key, HKD f Value)]

-- | These are the fields that are common only up to major protocol version
--   6
shelleyCommonPParamsHKDPairsV6 :: forall f era. (HKDFunctor f, EraPParams era, ProtVerAtMost era 6) => Proxy f -> PParamsHKD f era -> [(Key, HKD f Value)]
shelleyCommonPParamsHKDPairsV8 :: forall f era. (HKDFunctor f, EraPParams era, ProtVerAtMost era 8) => Proxy f -> PParamsHKD f era -> [(Key, HKD f Value)]

-- | <i>Deprecated: Use applyPPUpdates instead</i>
updatePParams :: EraPParams era => PParams era -> PParamsUpdate era -> PParams era
upgradeUpdate :: forall era. (EraPParams era, EraPParams (PreviousEra era), EraCrypto (PreviousEra era) ~ EraCrypto era) => UpgradePParams StrictMaybe era -> Update (PreviousEra era) -> Update era
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.PParams.ShelleyPParams f era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.PParams.PPUpdateEnv era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.PParams.PPUpdateEnv era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.PParams.PPUpdateEnv era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.PParams.Update era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParams.PParamsUpdate era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.PParams.Update era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParams.PParamsUpdate era) => GHC.Show.Show (Cardano.Ledger.Shelley.PParams.Update era)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParams.PParamsUpdate era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Core.PParams.PParamsUpdate era) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParams.PParamsUpdate era) => GHC.Show.Show (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Core.PParams.PParamsUpdate era) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.PParams.Update era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParams.PParamsUpdate era) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PParams.Update era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.PParams.Update era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.PParams.Update era)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.PParams.PParamsUpdate era) => Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.PParams.Update era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParams.PParamsUpdate era) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance Cardano.Ledger.Core.PParams.EraPParams era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.PParams.PParamsUpdate era) => Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PParams.PPUpdateEnv era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Core.PParams.EraPParams (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)
instance (Cardano.Ledger.Core.PParams.EraPParams era, Cardano.Ledger.Core.PParams.PParamsHKD Data.Functor.Identity.Identity era GHC.Types.~ Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era, Cardano.Ledger.Core.Era.ProtVerAtMost era 4, Cardano.Ledger.Core.Era.ProtVerAtMost era 6, Cardano.Ledger.Core.Era.ProtVerAtMost era 8) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era)
instance (Cardano.Ledger.Core.PParams.EraPParams era, Cardano.Ledger.Core.PParams.PParamsHKD Data.Maybe.Strict.StrictMaybe era GHC.Types.~ Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era, Cardano.Ledger.Core.Era.ProtVerAtMost era 4, Cardano.Ledger.Core.Era.ProtVerAtMost era 6, Cardano.Ledger.Core.Era.ProtVerAtMost era 8) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Maybe.Strict.StrictMaybe era)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.PParams.ShelleyPParams Data.Functor.Identity.Identity era)

module Cardano.Ledger.Shelley.Governance
class (EraPParams era, Eq (GovState era), Show (GovState era), NoThunks (GovState era), NFData (GovState era), EncCBOR (GovState era), DecCBOR (GovState era), DecShareCBOR (GovState era), ToCBOR (GovState era), FromCBOR (GovState era), Default (GovState era), ToJSON (GovState era)) => EraGov era where {
    type GovState era = (r :: Type) | r -> era;
}

-- | Construct empty governance state
emptyGovState :: EraGov era => GovState era

-- | Returns <a>Nothing</a> for all eras starting with Conway, otherwise
--   returns proposed pparams updates
getProposedPPUpdates :: EraGov era => GovState era -> Maybe (ProposedPPUpdates era)

-- | Returns <a>Nothing</a> for all era preceding Conway, otherwise returns
--   the hash of the constitution
getConstitution :: EraGov era => GovState era -> Maybe (Constitution era)
getCommitteeMembers :: EraGov era => GovState era -> Maybe (Map (Credential 'ColdCommitteeRole (EraCrypto era)) EpochNo, UnitInterval)

-- | Lens for accessing current protocol parameters
curPParamsGovStateL :: EraGov era => Lens' (GovState era) (PParams era)

-- | Lens for accessing the previous protocol parameters
prevPParamsGovStateL :: EraGov era => Lens' (GovState era) (PParams era)
obligationGovState :: EraGov era => GovState era -> Coin
getDRepDistr :: EraGov era => GovState era -> Map (DRep (EraCrypto era)) (CompactForm Coin)
data ShelleyGovState era
ShelleyGovState :: !ProposedPPUpdates era -> !ProposedPPUpdates era -> !PParams era -> !PParams era -> ShelleyGovState era
[proposals] :: ShelleyGovState era -> !ProposedPPUpdates era
[futureProposals] :: ShelleyGovState era -> !ProposedPPUpdates era
[sgovPp] :: ShelleyGovState era -> !PParams era
[sgovPrevPp] :: ShelleyGovState era -> !PParams era
data Constitution era
Constitution :: !Anchor (EraCrypto era) -> !StrictMaybe (ScriptHash (EraCrypto era)) -> Constitution era
[constitutionAnchor] :: Constitution era -> !Anchor (EraCrypto era)
[constitutionScript] :: Constitution era -> !StrictMaybe (ScriptHash (EraCrypto era))
proposalsL :: Lens' (ShelleyGovState era) (ProposedPPUpdates era)
futureProposalsL :: Lens' (ShelleyGovState era) (ProposedPPUpdates era)
curPParamsShelleyGovStateL :: Lens' (ShelleyGovState era) (PParams era)
prevPParamsShelleyGovStateL :: Lens' (ShelleyGovState era) (PParams era)
constitutionAnchorL :: Lens' (Constitution era) (Anchor (EraCrypto era))
constitutionScriptL :: Lens' (Constitution era) (StrictMaybe (ScriptHash (EraCrypto era)))
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.Governance.Constitution era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Governance.Constitution era)
instance (GHC.Show.Show (Cardano.Ledger.Core.PParams.PParamsUpdate era), GHC.Show.Show (Cardano.Ledger.Core.PParams.PParams era)) => GHC.Show.Show (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance (GHC.Classes.Eq (Cardano.Ledger.Core.PParams.PParamsUpdate era), GHC.Classes.Eq (Cardano.Ledger.Core.PParams.PParams era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Governance.Constitution era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Governance.Constitution era)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Governance.EraGov (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.Governance.Constitution era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.Governance.Constitution era)
instance Cardano.Ledger.Core.Era.Era era => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.Governance.Constitution era)
instance Cardano.Ledger.Core.Era.Era era => Data.Default.Class.Default (Cardano.Ledger.Shelley.Governance.Constitution era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.Governance.Constitution era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.Governance.Constitution era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Governance.Constitution era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Governance.Constitution era)
instance Cardano.Ledger.Core.Era.Era era => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Governance.Constitution era)
instance Cardano.Ledger.Core.Era.Era era => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Governance.Constitution era)
instance (Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.PParams.PParamsUpdate era), Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.PParams.PParams era)) => Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance (Control.DeepSeq.NFData (Cardano.Ledger.Core.PParams.PParamsUpdate era), Control.DeepSeq.NFData (Cardano.Ledger.Core.PParams.PParams era)) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance (NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParams.PParamsUpdate era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParams.PParams era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era), Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.PParams.PParams era)) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.PParams.PParams era)) => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.PParams.PParams era)) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era), Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.PParams.PParams era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.PParams.PParams era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance Cardano.Ledger.Core.PParams.EraPParams era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)
instance Cardano.Ledger.Core.PParams.EraPParams era => Data.Default.Class.Default (Cardano.Ledger.Shelley.Governance.ShelleyGovState era)


-- | <i>Deprecated: Use 'import Cardano.Ledger.PoolParams' instead</i>
module Cardano.Ledger.Shelley.PoolParams

module Cardano.Ledger.Shelley.Scripts
data MultiSig era
pattern RequireAllOf :: Era era => [MultiSig era] -> MultiSig era
pattern RequireAnyOf :: Era era => [MultiSig era] -> MultiSig era
pattern RequireSignature :: Era era => KeyHash 'Witness (EraCrypto era) -> MultiSig era
pattern RequireMOf :: Era era => Int -> [MultiSig era] -> MultiSig era

-- | Script evaluator for native multi-signature scheme. <tt>vhks</tt> is
--   the set of key hashes that signed the transaction to be validated.
evalMultiSig :: Era era => Set (KeyHash 'Witness (EraCrypto era)) -> MultiSig era -> Bool

-- | Script validator for native multi-signature scheme.
validateMultiSig :: EraTx era => Tx era -> MultiSig era -> Bool
newtype () => ScriptHash c
ScriptHash :: Hash (ADDRHASH c) EraIndependentScript -> ScriptHash c

-- | Magic number "memorialized" in the ValidateScript class under the
--   method: scriptPrefixTag:: Core.Script era -&gt; Bs.ByteString, for the
--   Shelley Era.
nativeMultiSigTag :: ByteString

-- | Check the equality of two underlying types, while ignoring their
--   binary representation, which <a>Eq</a> instance normally does. This is
--   used for testing.
eqMultiSigRaw :: MultiSig era -> MultiSig era -> Bool
instance Data.Typeable.Internal.Typeable era => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Scripts.MultiSigRaw era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Scripts.MultiSigRaw era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Scripts.MultiSigRaw era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Shelley.Scripts.MultiSig era)
instance Data.Typeable.Internal.Typeable era => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Scripts.MultiSig era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Scripts.MultiSig era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Scripts.MultiSig era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Scripts.MultiSig era)
instance Cardano.Crypto.Hash.Class.HashAlgorithm (Cardano.Ledger.Crypto.HASH (Cardano.Ledger.Core.Era.EraCrypto era)) => GHC.Show.Show (Cardano.Ledger.Shelley.Scripts.MultiSigRaw era)
instance Cardano.Crypto.Hash.Class.HashAlgorithm (Cardano.Ledger.Crypto.HASH (Cardano.Ledger.Core.Era.EraCrypto era)) => GHC.Show.Show (Cardano.Ledger.Shelley.Scripts.MultiSig era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Scripts.MultiSig era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Shelley.Scripts.MultiSig era))
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Scripts.MultiSigRaw era)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.Scripts.MultiSigRaw era)
instance Cardano.Ledger.MemoBytes.Memoized Cardano.Ledger.Shelley.Scripts.MultiSig
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Core.EraScript (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.Scripts.MultiSig era)
instance Cardano.Ledger.MemoBytes.EqRaw (Cardano.Ledger.Shelley.Scripts.MultiSig era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.Scripts.MultiSig era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Shelley.Scripts.MultiSigRaw era))

module Cardano.Ledger.Shelley.SoftForks
validMetadata :: ProtVer -> Bool
restrictPoolMetadataHash :: ProtVer -> Bool

module Cardano.Ledger.Shelley.StabilityWindow

-- | Calculate the stability window (e.g. the number of slots needed for a
--   block to become stable) from the security param and the active slot
--   coefficient.
--   
--   The value 3k/f is determined to be a suitabe value as per
--   <a>https://docs.google.com/document/d/1B8BNMx8jVWRjYiUBOaI3jfZ7dQNvNTSDODvT5iOuYCU/edit#heading=h.qh2zcajmu6hm</a>
computeStabilityWindow :: Word64 -> ActiveSlotCoeff -> Word64

-- | Calculate the randomness stabilisation window from the security param
--   and the active slot coefficient.
--   
--   The value 4k/f is determined to be a suitabe value as per
--   <a>https://docs.google.com/document/d/1B8BNMx8jVWRjYiUBOaI3jfZ7dQNvNTSDODvT5iOuYCU/edit#heading=h.qh2zcajmu6hm</a>
computeRandomnessStabilisationWindow :: Word64 -> ActiveSlotCoeff -> Word64

module Cardano.Ledger.Shelley.TxAuxData

-- | A generic metadatum type.
data Metadatum
Map :: ![(Metadatum, Metadatum)] -> Metadatum
List :: ![Metadatum] -> Metadatum
I :: !Integer -> Metadatum
B :: !ByteString -> Metadatum
S :: !Text -> Metadatum
data ShelleyTxAuxData era
pattern ShelleyTxAuxData :: forall era. Era era => Map Word64 Metadatum -> ShelleyTxAuxData era
hashShelleyTxAuxData :: Era era => ShelleyTxAuxData era -> SafeHash (EraCrypto era) EraIndependentTxAuxData
validMetadatum :: Metadatum -> Bool

-- | <i>Deprecated: Use <a>ShelleyTxAuxData</a> instead</i>
type Metadata era = ShelleyTxAuxData era
instance GHC.Generics.Generic Cardano.Ledger.Shelley.TxAuxData.Metadatum
instance GHC.Classes.Ord Cardano.Ledger.Shelley.TxAuxData.Metadatum
instance GHC.Classes.Eq Cardano.Ledger.Shelley.TxAuxData.Metadatum
instance GHC.Show.Show Cardano.Ledger.Shelley.TxAuxData.Metadatum
instance Data.Typeable.Internal.Typeable era => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Core.EraTxAuxData (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance Cardano.Ledger.MemoBytes.EqRaw (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era)
instance (c GHC.Types.~ Cardano.Ledger.Core.Era.EraCrypto era) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era) Cardano.Ledger.Hashes.EraIndependentTxAuxData c
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era)
instance Data.Typeable.Internal.Typeable era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Shelley.TxAuxData.ShelleyTxAuxData era))
instance Data.TreeDiff.Class.ToExpr Cardano.Ledger.Shelley.TxAuxData.Metadatum
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.TxAuxData.Metadatum
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.TxAuxData.Metadatum
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Shelley.TxAuxData.Metadatum
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Shelley.TxAuxData.Metadatum


-- | <i>Deprecated: Use 'import Cardano.Ledger.Shelley.TxAuxData'
--   instead</i>
module Cardano.Ledger.Shelley.Metadata

module Cardano.Ledger.Shelley.TxCert
class EraTxCert era => ShelleyEraTxCert era
mkRegTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> TxCert era
getRegTxCert :: ShelleyEraTxCert era => TxCert era -> Maybe (StakeCredential (EraCrypto era))
mkUnRegTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> TxCert era
getUnRegTxCert :: ShelleyEraTxCert era => TxCert era -> Maybe (StakeCredential (EraCrypto era))
mkDelegStakeTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> KeyHash 'StakePool (EraCrypto era) -> TxCert era
getDelegStakeTxCert :: ShelleyEraTxCert era => TxCert era -> Maybe (StakeCredential (EraCrypto era), KeyHash 'StakePool (EraCrypto era))
mkGenesisDelegTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => GenesisDelegCert (EraCrypto era) -> TxCert era
getGenesisDelegTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => TxCert era -> Maybe (GenesisDelegCert (EraCrypto era))
mkMirTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => MIRCert (EraCrypto era) -> TxCert era
getMirTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => TxCert era -> Maybe (MIRCert (EraCrypto era))
pattern MirTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => MIRCert (EraCrypto era) -> TxCert era
pattern GenesisDelegTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => KeyHash 'Genesis (EraCrypto era) -> KeyHash 'GenesisDelegate (EraCrypto era) -> Hash (EraCrypto era) (VerKeyVRF (EraCrypto era)) -> TxCert era
pattern RegTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> TxCert era
pattern UnRegTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> TxCert era
pattern DelegStakeTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> KeyHash 'StakePool (EraCrypto era) -> TxCert era
data ShelleyDelegCert c

-- | A stake credential registration certificate.
ShelleyRegCert :: !StakeCredential c -> ShelleyDelegCert c

-- | A stake credential deregistration certificate.
ShelleyUnRegCert :: !StakeCredential c -> ShelleyDelegCert c

-- | A stake delegation certificate.
ShelleyDelegCert :: !StakeCredential c -> !KeyHash 'StakePool c -> ShelleyDelegCert c

-- | <i>Deprecated: In favor of <a>ShelleyRegCert</a></i>
pattern RegKey :: StakeCredential c -> ShelleyDelegCert c

-- | <i>Deprecated: In favor of <a>ShelleyUnRegCert</a></i>
pattern DeRegKey :: StakeCredential c -> ShelleyDelegCert c

-- | <i>Deprecated: In favor of <a>ShelleyDelegCert</a></i>
pattern Delegate :: Delegation c -> ShelleyDelegCert c
getVKeyWitnessShelleyTxCert :: ShelleyTxCert era -> Maybe (KeyHash 'Witness (EraCrypto era))
getScriptWitnessShelleyTxCert :: ShelleyTxCert era -> Maybe (ScriptHash (EraCrypto era))

-- | Determine the certificate author

-- | <i>Deprecated: This was a partial function, logic rewritten in a safer
--   way</i>
delegCWitness :: ShelleyDelegCert c -> Credential 'Staking c

-- | A heavyweight certificate.
data ShelleyTxCert era
ShelleyTxCertDelegCert :: !ShelleyDelegCert (EraCrypto era) -> ShelleyTxCert era
ShelleyTxCertPool :: !PoolCert (EraCrypto era) -> ShelleyTxCert era
ShelleyTxCertGenesisDeleg :: !GenesisDelegCert (EraCrypto era) -> ShelleyTxCert era
ShelleyTxCertMir :: !MIRCert (EraCrypto era) -> ShelleyTxCert era
upgradeShelleyTxCert :: EraCrypto era1 ~ EraCrypto era2 => ShelleyTxCert era1 -> ShelleyTxCert era2

-- | Genesis key delegation certificate
data GenesisDelegCert c
GenesisDelegCert :: !KeyHash 'Genesis c -> !KeyHash 'GenesisDelegate c -> !Hash c (VerKeyVRF c) -> GenesisDelegCert c
genesisCWitness :: GenesisDelegCert c -> KeyHash 'Genesis c
genesisKeyHashWitness :: GenesisDelegCert c -> KeyHash 'Witness c

-- | Move instantaneous rewards certificate
data MIRCert c
MIRCert :: !MIRPot -> !MIRTarget c -> MIRCert c
[mirPot] :: MIRCert c -> !MIRPot
[mirRewards] :: MIRCert c -> !MIRTarget c
data MIRPot
ReservesMIR :: MIRPot
TreasuryMIR :: MIRPot

-- | MIRTarget specifies if funds from either the reserves or the treasury
--   are to be handed out to a collection of reward accounts or instead
--   transfered to the opposite pot.
data MIRTarget c
StakeAddressesMIR :: !Map (Credential 'Staking c) DeltaCoin -> MIRTarget c
SendToOppositePotMIR :: !Coin -> MIRTarget c

-- | Check for <a>ShelleyRegCert</a> constructor

-- | <i>Deprecated: Use <a>isRegStakeTxCert</a> instead</i>
isRegKey :: ShelleyEraTxCert era => TxCert era -> Bool

-- | Check for <a>ShelleyUnRegCert</a> constructor

-- | <i>Deprecated: Use <a>isUnRegStakeTxCert</a> instead</i>
isDeRegKey :: ShelleyEraTxCert era => TxCert era -> Bool

-- | Check for <a>ShelleyDelegCert</a> constructor
isDelegation :: ShelleyEraTxCert era => TxCert era -> Bool

-- | Check for <a>RegPool</a> constructor
isRegPool :: EraTxCert era => TxCert era -> Bool

-- | Check for <a>RetirePool</a> constructor
isRetirePool :: EraTxCert era => TxCert era -> Bool

-- | Check for <a>GenesisDelegate</a> constructor
isGenesisDelegation :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => TxCert era -> Bool
isInstantaneousRewards :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => TxCert era -> Bool
isReservesMIRCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => TxCert era -> Bool
isTreasuryMIRCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => TxCert era -> Bool

-- | Returns True for delegation certificates that require at least one
--   witness, and False otherwise. It is mainly used to ensure that calling
--   a variant of <tt>cwitness</tt> is safe.
--   
--   Note: This will not compile for Conway, because it is incorrect for
--   Conway, use <a>getVKeyWitnessTxCert</a> instead.

-- | <i>Deprecated: In favor of <a>getVKeyWitnessTxCert</a></i>
requiresVKeyWitness :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => TxCert era -> Bool
shelleyTxCertDelegDecoder :: ShelleyEraTxCert era => Word -> Decoder s (Int, TxCert era)
poolTxCertDecoder :: EraTxCert era => Word -> Decoder s (Int, TxCert era)
encodeShelleyDelegCert :: Crypto c => ShelleyDelegCert c -> Encoding
encodePoolCert :: Crypto c => PoolCert c -> Encoding
encodeGenesisDelegCert :: Crypto c => GenesisDelegCert c -> Encoding
class (Era era, DecCBOR TxCert era, EncCBOR TxCert era, ToCBOR TxCert era, FromCBOR TxCert era, NoThunks TxCert era, NFData TxCert era, Show TxCert era, Eq TxCert era, ToExpr TxCert era) => EraTxCert era where {
    type family TxCert era = (r :: Type) | r -> era;
    type family TxCertUpgradeError era;
    type TxCertUpgradeError era = Void;
}
upgradeTxCert :: EraTxCert era => TxCert (PreviousEra era) -> Either (TxCertUpgradeError era) (TxCert era)
getVKeyWitnessTxCert :: EraTxCert era => TxCert era -> Maybe (KeyHash 'Witness (EraCrypto era))
getScriptWitnessTxCert :: EraTxCert era => TxCert era -> Maybe (ScriptHash (EraCrypto era))
mkRegPoolTxCert :: EraTxCert era => PoolParams (EraCrypto era) -> TxCert era
getRegPoolTxCert :: EraTxCert era => TxCert era -> Maybe (PoolParams (EraCrypto era))
mkRetirePoolTxCert :: EraTxCert era => KeyHash 'StakePool (EraCrypto era) -> EpochNo -> TxCert era
getRetirePoolTxCert :: EraTxCert era => TxCert era -> Maybe (KeyHash 'StakePool (EraCrypto era), EpochNo)
lookupRegStakeTxCert :: EraTxCert era => TxCert era -> Maybe (Credential 'Staking (EraCrypto era))
lookupUnRegStakeTxCert :: EraTxCert era => TxCert era -> Maybe (Credential 'Staking (EraCrypto era))
pattern RegPoolTxCert :: EraTxCert era => PoolParams (EraCrypto era) -> TxCert era
pattern RetirePoolTxCert :: EraTxCert era => KeyHash 'StakePool (EraCrypto era) -> EpochNo -> TxCert era
data () => Delegation c
Delegation :: !StakeCredential c -> !KeyHash 'StakePool c -> Delegation c
[dDelegator] :: Delegation c -> !StakeCredential c
[dDelegatee] :: Delegation c -> !KeyHash 'StakePool c
data () => PoolCert c
RegPool :: !PoolParams c -> PoolCert c
RetirePool :: !KeyHash 'StakePool c -> !EpochNo -> PoolCert c
poolCWitness :: PoolCert c -> Credential 'StakePool c
isRegStakeTxCert :: EraTxCert era => TxCert era -> Bool
isUnRegStakeTxCert :: EraTxCert era => TxCert era -> Bool
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxCert.GenesisDelegCert c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxCert.GenesisDelegCert c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxCert.GenesisDelegCert c)
instance GHC.Enum.Bounded Cardano.Ledger.Shelley.TxCert.MIRPot
instance GHC.Enum.Enum Cardano.Ledger.Shelley.TxCert.MIRPot
instance GHC.Classes.Ord Cardano.Ledger.Shelley.TxCert.MIRPot
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.TxCert.MIRPot
instance GHC.Classes.Eq Cardano.Ledger.Shelley.TxCert.MIRPot
instance GHC.Generics.Generic Cardano.Ledger.Shelley.TxCert.MIRPot
instance GHC.Show.Show Cardano.Ledger.Shelley.TxCert.MIRPot
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxCert.MIRTarget c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxCert.MIRTarget c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxCert.MIRTarget c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxCert.MIRTarget c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxCert.MIRCert c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxCert.MIRCert c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxCert.MIRCert c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxCert.MIRCert c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxCert.ShelleyDelegCert c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxCert.ShelleyDelegCert c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxCert.ShelleyDelegCert c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.TxCert.MIRPot
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxCert.MIRTarget c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Core.TxCert.EraTxCert (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.TxCert.ShelleyEraTxCert (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance (Cardano.Ledger.Shelley.TxCert.ShelleyEraTxCert era, Cardano.Ledger.Core.TxCert.TxCert era GHC.Types.~ Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance (Cardano.Ledger.Shelley.TxCert.ShelleyEraTxCert era, Cardano.Ledger.Core.TxCert.TxCert era GHC.Types.~ Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.TxCert.ShelleyTxCert era)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.TxCert.ShelleyDelegCert c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxCert.ShelleyDelegCert c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxCert.ShelleyDelegCert c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxCert.MIRCert c)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.TxCert.MIRCert c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.TxCert.MIRCert c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.TxCert.MIRCert c)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.TxCert.MIRTarget c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.TxCert.MIRTarget c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.TxCert.MIRTarget c)
instance Data.TreeDiff.Class.ToExpr Cardano.Ledger.Shelley.TxCert.MIRPot
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Shelley.TxCert.MIRPot
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Shelley.TxCert.MIRPot
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxCert.GenesisDelegCert c)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.TxCert.GenesisDelegCert c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxCert.GenesisDelegCert c)


-- | <i>Deprecated: Use <a>TxCert</a> instead</i>
module Cardano.Ledger.Shelley.Delegation.Certificates

module Cardano.Ledger.Shelley.Core
class (ShelleyEraTxCert era, EraTxBody era) => ShelleyEraTxBody era
ttlTxBodyL :: (ShelleyEraTxBody era, ExactEra ShelleyEra era) => Lens' (TxBody era) SlotNo
updateTxBodyL :: (ShelleyEraTxBody era, ProtVerAtMost era 8) => Lens' (TxBody era) (StrictMaybe (Update era))

-- | <i>Deprecated: Use <a>updateTxBodyL</a> instead</i>
updateTxBodyG :: ShelleyEraTxBody era => SimpleGetter (TxBody era) (StrictMaybe (Update era))

-- | <i>Deprecated: Use <a>updateTxBodyL</a> instead</i>
updateTxBodyG :: (ShelleyEraTxBody era, ProtVerAtMost era 8) => SimpleGetter (TxBody era) (StrictMaybe (Update era))
getTotalDepositsTxBody :: ShelleyEraTxBody era => PParams era -> CertState era -> TxBody era -> Coin
pattern MirTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => MIRCert (EraCrypto era) -> TxCert era
class EraTxCert era => ShelleyEraTxCert era
mkRegTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> TxCert era
getRegTxCert :: ShelleyEraTxCert era => TxCert era -> Maybe (StakeCredential (EraCrypto era))
mkUnRegTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> TxCert era
getUnRegTxCert :: ShelleyEraTxCert era => TxCert era -> Maybe (StakeCredential (EraCrypto era))
mkDelegStakeTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> KeyHash 'StakePool (EraCrypto era) -> TxCert era
getDelegStakeTxCert :: ShelleyEraTxCert era => TxCert era -> Maybe (StakeCredential (EraCrypto era), KeyHash 'StakePool (EraCrypto era))
mkGenesisDelegTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => GenesisDelegCert (EraCrypto era) -> TxCert era
getGenesisDelegTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => TxCert era -> Maybe (GenesisDelegCert (EraCrypto era))
mkMirTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => MIRCert (EraCrypto era) -> TxCert era
getMirTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => TxCert era -> Maybe (MIRCert (EraCrypto era))
newtype () => Withdrawals c
Withdrawals :: Map (RewardAcnt c) Coin -> Withdrawals c
[unWithdrawals] :: Withdrawals c -> Map (RewardAcnt c) Coin

-- | <i>Deprecated: In favor of <a>Withdrawals</a></i>
type Wdrl c = Withdrawals c

-- | <i>Deprecated: In favor of <a>Withdrawals</a></i>
pattern Wdrl :: Map (RewardAcnt c) Coin -> Withdrawals c

module Cardano.Ledger.Shelley.TxOut
data ShelleyTxOut era
TxOutCompact :: {-# UNPACK #-} !CompactAddr (EraCrypto era) -> !CompactForm (Value era) -> ShelleyTxOut era
pattern ShelleyTxOut :: (HasCallStack, Era era, Val (Value era)) => Addr (EraCrypto era) -> Value era -> ShelleyTxOut era
addrEitherShelleyTxOutL :: Lens' (ShelleyTxOut era) (Either (Addr (EraCrypto era)) (CompactAddr (EraCrypto era)))
valueEitherShelleyTxOutL :: Val (Value era) => Lens' (ShelleyTxOut era) (Either (Value era) (CompactForm (Value era)))
instance GHC.Classes.Eq (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Core.Value era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Core.EraTxOut (Cardano.Ledger.Shelley.Era.ShelleyEra crypto)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.HeapWords.HeapWords (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Core.Value era))) => Cardano.HeapWords.HeapWords (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Val.Val (Cardano.Ledger.Core.Value era)) => GHC.Show.Show (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Core.Value era))) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Core.Value era))) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Core.Value era))) => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Core.Value era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Core.Value era))) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Val.Val (Cardano.Ledger.Core.Value era)) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)
instance (Cardano.Ledger.Core.EraTxOut era, Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.Value era)) => Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.TxOut.ShelleyTxOut era)

module Cardano.Ledger.Shelley.TxBody
data ShelleyDelegCert c
data () => Delegation c
Delegation :: !StakeCredential c -> !KeyHash 'StakePool c -> Delegation c
[dDelegator] :: Delegation c -> !StakeCredential c
[dDelegatee] :: Delegation c -> !KeyHash 'StakePool c

-- | Genesis key delegation certificate
data GenesisDelegCert c
GenesisDelegCert :: !KeyHash 'Genesis c -> !KeyHash 'GenesisDelegate c -> !Hash c (VerKeyVRF c) -> GenesisDelegCert c

-- | Move instantaneous rewards certificate
data MIRCert c
MIRCert :: !MIRPot -> !MIRTarget c -> MIRCert c
[mirPot] :: MIRCert c -> !MIRPot
[mirRewards] :: MIRCert c -> !MIRTarget c
data MIRPot
ReservesMIR :: MIRPot
TreasuryMIR :: MIRPot

-- | MIRTarget specifies if funds from either the reserves or the treasury
--   are to be handed out to a collection of reward accounts or instead
--   transfered to the opposite pot.
data MIRTarget c
StakeAddressesMIR :: !Map (Credential 'Staking c) DeltaCoin -> MIRTarget c
SendToOppositePotMIR :: !Coin -> MIRTarget c
data () => PoolCert c
RegPool :: !PoolParams c -> PoolCert c
RetirePool :: !KeyHash 'StakePool c -> !EpochNo -> PoolCert c
data () => PoolMetadata
PoolMetadata :: !Url -> !ByteString -> PoolMetadata
[pmUrl] :: PoolMetadata -> !Url
[pmHash] :: PoolMetadata -> !ByteString
data () => PoolParams c
PoolParams :: !KeyHash 'StakePool c -> !Hash c (VerKeyVRF c) -> !Coin -> !Coin -> !UnitInterval -> !RewardAcnt c -> !Set (KeyHash 'Staking c) -> !StrictSeq StakePoolRelay -> !StrictMaybe PoolMetadata -> PoolParams c
[ppId] :: PoolParams c -> !KeyHash 'StakePool c
[ppVrf] :: PoolParams c -> !Hash c (VerKeyVRF c)
[ppPledge] :: PoolParams c -> !Coin
[ppCost] :: PoolParams c -> !Coin
[ppMargin] :: PoolParams c -> !UnitInterval
[ppRewardAcnt] :: PoolParams c -> !RewardAcnt c
[ppOwners] :: PoolParams c -> !Set (KeyHash 'Staking c)
[ppRelays] :: PoolParams c -> !StrictSeq StakePoolRelay
[ppMetadata] :: PoolParams c -> !StrictMaybe PoolMetadata
data () => Ptr
Ptr :: !SlotNo -> !TxIx -> !CertIx -> Ptr
data () => RewardAcnt c
RewardAcnt :: !Network -> !Credential 'Staking c -> RewardAcnt c
[getRwdNetwork] :: RewardAcnt c -> !Network
[getRwdCred] :: RewardAcnt c -> !Credential 'Staking c
data () => StakePoolRelay
SingleHostAddr :: !StrictMaybe Port -> !StrictMaybe IPv4 -> !StrictMaybe IPv6 -> StakePoolRelay
SingleHostName :: !StrictMaybe Port -> !DnsName -> StakePoolRelay
MultiHostName :: !DnsName -> StakePoolRelay
newtype ShelleyTxBody era
TxBodyConstr :: MemoBytes ShelleyTxBodyRaw era -> ShelleyTxBody era

-- | Pattern for use by external users
pattern ShelleyTxBody :: (EraTxOut era, EncCBOR (TxCert era)) => Set (TxIn (EraCrypto era)) -> StrictSeq (TxOut era) -> StrictSeq (TxCert era) -> Withdrawals (EraCrypto era) -> Coin -> SlotNo -> StrictMaybe (Update era) -> StrictMaybe (AuxiliaryDataHash (EraCrypto era)) -> ShelleyTxBody era
class (ShelleyEraTxCert era, EraTxBody era) => ShelleyEraTxBody era
ttlTxBodyL :: (ShelleyEraTxBody era, ExactEra ShelleyEra era) => Lens' (TxBody era) SlotNo
updateTxBodyL :: (ShelleyEraTxBody era, ProtVerAtMost era 8) => Lens' (TxBody era) (StrictMaybe (Update era))

-- | <i>Deprecated: Use <a>updateTxBodyL</a> instead</i>
updateTxBodyG :: ShelleyEraTxBody era => SimpleGetter (TxBody era) (StrictMaybe (Update era))

-- | <i>Deprecated: Use <a>updateTxBodyL</a> instead</i>
updateTxBodyG :: (ShelleyEraTxBody era, ProtVerAtMost era 8) => SimpleGetter (TxBody era) (StrictMaybe (Update era))
getTotalDepositsTxBody :: ShelleyEraTxBody era => PParams era -> CertState era -> TxBody era -> Coin
data ShelleyTxBodyRaw era
ShelleyTxBodyRaw :: !Set (TxIn (EraCrypto era)) -> !StrictSeq (TxOut era) -> !StrictSeq (TxCert era) -> !Withdrawals (EraCrypto era) -> !Coin -> !SlotNo -> !StrictMaybe (Update era) -> !StrictMaybe (AuxiliaryDataHash (EraCrypto era)) -> ShelleyTxBodyRaw era
[stbrInputs] :: ShelleyTxBodyRaw era -> !Set (TxIn (EraCrypto era))
[stbrOutputs] :: ShelleyTxBodyRaw era -> !StrictSeq (TxOut era)
[stbrCerts] :: ShelleyTxBodyRaw era -> !StrictSeq (TxCert era)
[stbrWithdrawals] :: ShelleyTxBodyRaw era -> !Withdrawals (EraCrypto era)
[stbrTxFee] :: ShelleyTxBodyRaw era -> !Coin
[stbrTTL] :: ShelleyTxBodyRaw era -> !SlotNo
[stbrUpdate] :: ShelleyTxBodyRaw era -> !StrictMaybe (Update era)
[stbrMDHash] :: ShelleyTxBodyRaw era -> !StrictMaybe (AuxiliaryDataHash (EraCrypto era))
data () => EraIndependentTxBody
type family TxOut era = (r :: Type) | r -> era
data ShelleyTxOut era
TxOutCompact :: {-# UNPACK #-} !CompactAddr (EraCrypto era) -> !CompactForm (Value era) -> ShelleyTxOut era
pattern ShelleyTxOut :: (HasCallStack, Era era, Val (Value era)) => Addr (EraCrypto era) -> Value era -> ShelleyTxOut era
data () => Url
newtype () => Withdrawals c
Withdrawals :: Map (RewardAcnt c) Coin -> Withdrawals c
[unWithdrawals] :: Withdrawals c -> Map (RewardAcnt c) Coin

-- | <i>Deprecated: In favor of <a>Withdrawals</a></i>
type Wdrl c = Withdrawals c

-- | <i>Deprecated: In favor of <a>Withdrawals</a></i>
pattern Wdrl :: Map (RewardAcnt c) Coin -> Withdrawals c

-- | <i>Deprecated: In favor of <a>witVKeyHash</a></i>
witKeyHash :: WitVKey kr c -> KeyHash 'Witness c

-- | <i>Deprecated: In favor of <a>witVKeyBytes</a></i>
wvkBytes :: WitVKey kr c -> ByteString
data () => SizeOfPoolOwners
SizeOfPoolOwners :: SizeOfPoolOwners
data () => SizeOfPoolRelays
SizeOfPoolRelays :: SizeOfPoolRelays
addrEitherShelleyTxOutL :: Lens' (ShelleyTxOut era) (Either (Addr (EraCrypto era)) (CompactAddr (EraCrypto era)))
valueEitherShelleyTxOutL :: Val (Value era) => Lens' (ShelleyTxOut era) (Either (Value era) (CompactForm (Value era)))

-- | Calculates the total amount of deposits needed for all pool
--   registration and stake delegation certificates to be valid.
totalTxDepositsShelley :: ShelleyEraTxBody era => PParams era -> CertState era -> TxBody era -> Coin
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.ShelleyTxBodyRaw era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era)
instance (NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxOut era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxCert.TxCert era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.ShelleyTxBodyRaw era)
instance (Cardano.Ledger.Core.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.TxOut era), Control.DeepSeq.NFData (Cardano.Ledger.Core.TxCert.TxCert era), Control.DeepSeq.NFData (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.ShelleyTxBodyRaw era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Cardano.Ledger.Core.TxCert.TxCert era), GHC.Classes.Eq (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.ShelleyTxBodyRaw era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Cardano.Ledger.Core.TxCert.TxCert era), GHC.Show.Show (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.ShelleyTxBodyRaw era)
instance (Cardano.Ledger.Core.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxOut era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxCert.TxCert era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era)
instance Cardano.Ledger.Core.EraTxBody era => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era)
instance Cardano.Ledger.Core.EraTxBody era => GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Cardano.Ledger.Core.TxCert.TxCert era), GHC.Classes.Eq (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era)
instance Cardano.Ledger.Core.EraTxBody era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era))
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era)
instance Cardano.Ledger.MemoBytes.Memoized Cardano.Ledger.Shelley.TxBody.ShelleyTxBody
instance (Cardano.Ledger.Core.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Cardano.Ledger.Core.TxCert.TxCert era), GHC.Classes.Eq (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => Cardano.Ledger.MemoBytes.EqRaw (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era)
instance (Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.TxOut era), Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.TxCert.TxCert era), Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.PParams.Update era)) => Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Core.EraTxBody (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance (Cardano.Ledger.Core.Era.Era era, c GHC.Types.~ Cardano.Ledger.Core.Era.EraCrypto era) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Shelley.TxBody.ShelleyTxBody era) Cardano.Ledger.Hashes.EraIndependentTxBody c
instance (Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.TxOut era), Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.TxCert.TxCert era), Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.PParams.Update era)) => Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.TxBody.ShelleyTxBodyRaw era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.TxCert.TxCert era)) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.TxBody.ShelleyTxBodyRaw era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Core.TxCert.TxCert era)) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Shelley.TxBody.ShelleyTxBodyRaw era))
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.TxCert.TxCert era), Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.PParams.PParamsUpdate era)) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.TxBody.ShelleyTxBodyRaw era)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Core.ShelleyEraTxBody (Cardano.Ledger.Shelley.Era.ShelleyEra c)

module Cardano.Ledger.Shelley.Rewards

-- | StakeShare type
newtype StakeShare
StakeShare :: Rational -> StakeShare
[unStakeShare] :: StakeShare -> Rational

-- | Stake Pool specific information needed to compute the rewards for its
--   members.
data PoolRewardInfo c
PoolRewardInfo :: !StakeShare -> !Coin -> !PoolParams c -> !Natural -> !LeaderOnlyReward c -> PoolRewardInfo c

-- | The stake pool's stake divided by the total stake
[poolRelativeStake] :: PoolRewardInfo c -> !StakeShare

-- | The maximum rewards available for the entire pool
[poolPot] :: PoolRewardInfo c -> !Coin

-- | The stake pool parameters
[poolPs] :: PoolRewardInfo c -> !PoolParams c

-- | The number of blocks the stake pool produced
[poolBlocks] :: PoolRewardInfo c -> !Natural

-- | The leader reward
[poolLeaderReward] :: PoolRewardInfo c -> !LeaderOnlyReward c

-- | Calculate pool reward
mkApparentPerformance :: UnitInterval -> Rational -> Natural -> Natural -> Rational
data () => RewardType
MemberReward :: RewardType
LeaderReward :: RewardType
data () => Reward c
Reward :: !RewardType -> !KeyHash 'StakePool c -> !Coin -> Reward c
[rewardType] :: Reward c -> !RewardType
[rewardPool] :: Reward c -> !KeyHash 'StakePool c
[rewardAmount] :: Reward c -> !Coin
data LeaderOnlyReward c
LeaderOnlyReward :: !KeyHash 'StakePool c -> !Coin -> LeaderOnlyReward c
[lRewardPool] :: LeaderOnlyReward c -> !KeyHash 'StakePool c
[lRewardAmount] :: LeaderOnlyReward c -> !Coin
leaderRewardToGeneral :: LeaderOnlyReward c -> Reward c

-- | Calculate pool leader reward
leaderRew :: Coin -> PoolParams c -> StakeShare -> StakeShare -> Coin

-- | Calculate pool member reward
memberRew :: Coin -> PoolParams c -> StakeShare -> StakeShare -> Coin

-- | for each (Set (Reward c)) entry in the map, sum up the coin. In the
--   ShelleyEra some of the coins are ignored (because of backward
--   compatibility) see <a>filterRewards</a> Note that domain of the
--   returned map is a subset of the input map <tt>rewards</tt>
aggregateRewards :: forall c. ProtVer -> Map (Credential 'Staking c) (Set (Reward c)) -> Map (Credential 'Staking c) Coin

-- | Filter the reward payments to those that will actually be delivered.
--   This function exists since in Shelley, a stake credential earning
--   rewards from multiple sources would only receive one reward. So some
--   of the coins are ignored, because of this backward compatibility issue
--   in early protocolVersions. Note that both of the domains of the
--   returned maps are a subset of the the domain of the input map
--   <tt>rewards</tt>
filterRewards :: forall c. ProtVer -> Map (Credential 'Staking c) (Set (Reward c)) -> (Map (Credential 'Staking c) (Set (Reward c)), Map (Credential 'Staking c) (Set (Reward c)))
sumRewards :: forall c. ProtVer -> Map (Credential 'Staking c) (Set (Reward c)) -> Coin

-- | for each (Set (Reward c)) entry in the map, sum up the coin. In the
--   ShelleyEra some of the coins are ignored (because of backward
--   compatibility) see <a>filterRewards</a> Note that the domain of the
--   output map is a subset of the domain of the input rewards.
aggregateCompactRewards :: ProtVer -> Map (Credential 'Staking c) (Set (Reward c)) -> Map (Credential 'Staking c) (CompactForm Coin)
sumCompactRewards :: ProtVer -> Map (Credential 'Staking c) (Set (Reward c)) -> CompactForm Coin

-- | The stake pool member reward calculation
rewardOnePoolMember :: ProtVer -> Coin -> Set (Credential 'Staking c) -> PoolRewardInfo c -> Credential 'Staking c -> Coin -> Maybe Coin

-- | Calculate single stake pool specific values for the reward
--   computation.
--   
--   Note that if a stake pool has made no blocks in the given epoch, it
--   will get no rewards, and so we do not need to return
--   <a>PoolRewardInfo</a>. We do, however, need to return the relative
--   stake of the pool in order to compute data for the stake pool ranking.
--   Eventually we will remove the ranking information out of the ledger
--   code and into a separate service, and at that point we can simplify
--   this function to not care about ranking.
mkPoolRewardInfo :: EraPParams era => PParams era -> Coin -> BlocksMade (EraCrypto era) -> Natural -> Stake (EraCrypto era) -> VMap VB VB (Credential 'Staking (EraCrypto era)) (KeyHash 'StakePool (EraCrypto era)) -> Map (KeyHash 'StakePool (EraCrypto era)) Coin -> Coin -> Coin -> PoolParams (EraCrypto era) -> Either StakeShare (PoolRewardInfo (EraCrypto era))
instance GHC.Show.Show Cardano.Ledger.Shelley.Rewards.StakeShare
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.Rewards.StakeShare
instance GHC.Classes.Eq Cardano.Ledger.Shelley.Rewards.StakeShare
instance GHC.Classes.Ord Cardano.Ledger.Shelley.Rewards.StakeShare
instance GHC.Generics.Generic Cardano.Ledger.Shelley.Rewards.StakeShare
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward c)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo c)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward c)
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.Rewards.StakeShare

module Cardano.Ledger.Shelley.RewardProvenance

-- | <tt>RewardProvenenace</tt> captures some of the intermediate
--   calculations when computing the staking reward distribution. Most of
--   these fields are simple scalar values, computed from the current
--   State, and are fixed before we start to compute the distribution. Two
--   of them are aggregates computed when we compute the distribution
--   (<a>pools</a> and <a>desirabilities</a>).
--   
--   For more background, see "Figure 48: The Reward Calculation" and
--   "Figure 51: Reward Update Creation" of the <a>the formal
--   specification</a>. The variable names here align with those in the
--   specification. See also Section 5 of the
--   <a>https://github.com/input-output-hk/cardano-ledger/releases/latest/download/shelley-delegation.pdf</a>
data RewardProvenance c
RewardProvenance :: !Word64 -> !BlocksMade c -> !Coin -> !Coin -> !Coin -> !Coin -> !Coin -> !Integer -> !Rational -> !Integer -> !Rational -> !Coin -> !Coin -> !Coin -> !Map (KeyHash 'StakePool c) (RewardProvenancePool c) -> !Map (KeyHash 'StakePool c) Desirability -> RewardProvenance c

-- | The number of slots per epoch.
[spe] :: RewardProvenance c -> !Word64

-- | A map from pool ID (the key hash of the stake pool operator's
--   verification key) to the number of blocks made in the given epoch.
[blocks] :: RewardProvenance c -> !BlocksMade c

-- | The maximum Lovelace supply. On mainnet, this value is equal to 45 *
--   10^15 (45 billion ADA).
[maxLL] :: RewardProvenance c -> !Coin

-- | The maximum amount of Lovelace which can be removed from the reserves
--   to be given out as rewards for the given epoch.
[deltaR1] :: RewardProvenance c -> !Coin

-- | The difference between the total Lovelace that could have been
--   distributed as rewards this epoch (which is <a>r</a>) and what was
--   actually distributed.
[deltaR2] :: RewardProvenance c -> !Coin

-- | The total Lovelace available for rewards for the given epoch, equal to
--   <a>rPot</a> less <a>deltaT1</a>.
[r] :: RewardProvenance c -> !Coin

-- | The maximum Lovelace supply (<a>maxLL</a>) less the current value of
--   the reserves.
[totalStake] :: RewardProvenance c -> !Coin

-- | The total number of blocks produced during the given epoch.
[blocksCount] :: RewardProvenance c -> !Integer

-- | The decentralization parameter.
[d] :: RewardProvenance c -> !Rational

-- | The number of blocks expected to be produced during the given epoch.
[expBlocks] :: RewardProvenance c -> !Integer

-- | The ratio of the number of blocks actually made versus the number of
--   blocks that were expected.
[eta] :: RewardProvenance c -> !Rational

-- | The reward pot for the given epoch, equal to <a>deltaR1</a> plus the
--   fee pot.
[rPot] :: RewardProvenance c -> !Coin

-- | The amount of Lovelace taken from the treasury for the given epoch.
[deltaT1] :: RewardProvenance c -> !Coin

-- | The amount of Lovelace that is delegated during the given epoch.
[activeStake] :: RewardProvenance c -> !Coin

-- | Individual stake pool provenance.
[pools] :: RewardProvenance c -> !Map (KeyHash 'StakePool c) (RewardProvenancePool c)

-- | A map from pool ID to the desirability score. See the <a>stake pool
--   ranking document</a>.
[desirabilities] :: RewardProvenance c -> !Map (KeyHash 'StakePool c) Desirability

-- | Provenance for an individual stake pool's reward calculation.
data RewardProvenancePool c
RewardProvenancePool :: !Natural -> !Rational -> !Rational -> !Coin -> !PoolParams c -> !Rational -> !Coin -> !Rational -> !Coin -> !Coin -> RewardProvenancePool c

-- | The number of blocks the pool produced.
[poolBlocksP] :: RewardProvenancePool c -> !Natural

-- | The stake pool's stake share (portion of the total stake).
[sigmaP] :: RewardProvenancePool c -> !Rational

-- | The stake pool's active stake share (portion of the active stake).
[sigmaAP] :: RewardProvenancePool c -> !Rational

-- | The number of Lovelace owned by the stake pool owners. If this value
--   is not at least as large as the <a>pledgeRatioP</a>, the stake pool
--   will not earn any rewards for the given epoch.
[ownerStakeP] :: RewardProvenancePool c -> !Coin

-- | The stake pool's registered parameters.
[poolParamsP] :: RewardProvenancePool c -> !PoolParams c

-- | The stake pool's pledge.
[pledgeRatioP] :: RewardProvenancePool c -> !Rational

-- | The maximum number of Lovelace this stake pool can earn.
[maxPP] :: RewardProvenancePool c -> !Coin

-- | The stake pool's apparent performance. See Section 5.5.2 of the
--   <a>https://github.com/input-output-hk/cardano-ledger/releases/latest/download/shelley-delegation.pdf</a>
[appPerfP] :: RewardProvenancePool c -> !Rational

-- | The total Lovelace earned by the stake pool.
[poolRP] :: RewardProvenancePool c -> !Coin

-- | The total Lovelace earned by the stake pool leader.
[lRewardP] :: RewardProvenancePool c -> !Coin

-- | The desirability score of a stake pool, as described in <a>"Reward
--   Sharing Schemes for Stake Pools"</a>. Additionally, the hit rate
--   estimation described in the <a>stake pool ranking document</a> is
--   included.
data Desirability
Desirability :: !Double -> !Double -> Desirability
[desirabilityScore] :: Desirability -> !Double
[hitRateEstimate] :: Desirability -> !Double
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool c)
instance GHC.Generics.Generic Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance GHC.Show.Show Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance GHC.Classes.Eq Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool c)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance c)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance c)
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Default.Class.Default (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool c)

module Cardano.Ledger.Shelley.PoolRank

-- | Desirability calculation for non-myopic utility, corresponding to f^~
--   in section 5.6.1 of "Design Specification for Delegation and
--   Incentives in Cardano"
desirability :: (NonNegativeInterval, Natural) -> Coin -> PoolParams c -> PerformanceEstimate -> Coin -> Double

-- | This is a estimate of the proportion of allowed blocks a pool will
--   make in the future. It is used for ranking pools in delegation.
newtype PerformanceEstimate
PerformanceEstimate :: Double -> PerformanceEstimate
[unPerformanceEstimate] :: PerformanceEstimate -> Double
data NonMyopic c
NonMyopic :: !Map (KeyHash 'StakePool c) Likelihood -> !Coin -> NonMyopic c
[likelihoodsNM] :: NonMyopic c -> !Map (KeyHash 'StakePool c) Likelihood
[rewardPotNM] :: NonMyopic c -> !Coin

-- | Computes the top ranked stake pools corresponding to section 5.6.1 of
--   "Design Specification for Delegation and Incentives in Cardano"
getTopRankedPools :: EraPParams era => Coin -> Coin -> PParams era -> Map (KeyHash 'StakePool c) (PoolParams c) -> Map (KeyHash 'StakePool c) PerformanceEstimate -> Set (KeyHash 'StakePool c)
getTopRankedPoolsVMap :: EraPParams era => Coin -> Coin -> PParams era -> VMap VB VB (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)) -> Map (KeyHash 'StakePool (EraCrypto era)) PerformanceEstimate -> Set (KeyHash 'StakePool (EraCrypto era))

-- | Compute the Non-Myopic Pool Stake
--   
--   This function implements non-myopic stake calculation in section 5.6.2
--   of "Design Specification for Delegation and Incentives in Cardano".
--   Note that the protocol parameters are implicit in the design document.
--   Additionally, instead of passing a rank r to compare with k, we pass
--   the top k desirable pools and check for membership.
nonMyopicStake :: EraPParams era => PParams era -> StakeShare -> StakeShare -> StakeShare -> KeyHash 'StakePool c -> Set (KeyHash 'StakePool c) -> StakeShare

-- | Compute the Non-Myopic Pool Member Reward
--   
--   This function implements equation (3) in section 5.6.4 of "Design
--   Specification for Delegation and Incentives in Cardano". Note that the
--   protocol parameters and the reward pot are implicit in the design
--   document. Additionally, instead of passing a rank r to compare with k,
--   we pass the top k desirable pools and check for membership.
nonMyopicMemberRew :: EraPParams era => PParams era -> Coin -> PoolParams c -> StakeShare -> StakeShare -> StakeShare -> Set (KeyHash 'StakePool c) -> PerformanceEstimate -> Coin
percentile' :: Likelihood -> PerformanceEstimate
newtype Histogram
Histogram :: StrictSeq LogWeight -> Histogram
[unHistogram] :: Histogram -> StrictSeq LogWeight
newtype LogWeight
LogWeight :: Float -> LogWeight
[unLogWeight] :: LogWeight -> Float
likelihood :: Natural -> Double -> EpochSize -> Likelihood

-- | Decay previous likelihood
applyDecay :: Float -> Likelihood -> Likelihood
newtype Likelihood
Likelihood :: StrictSeq LogWeight -> Likelihood
[unLikelihood] :: Likelihood -> StrictSeq LogWeight
leaderProbability :: ActiveSlotCoeff -> Rational -> UnitInterval -> Double
instance GHC.Show.Show Cardano.Ledger.Shelley.PoolRank.LogWeight
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Shelley.PoolRank.LogWeight
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.PoolRank.LogWeight
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Shelley.PoolRank.LogWeight
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Shelley.PoolRank.LogWeight
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.PoolRank.LogWeight
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.PoolRank.LogWeight
instance GHC.Num.Num Cardano.Ledger.Shelley.PoolRank.LogWeight
instance GHC.Classes.Ord Cardano.Ledger.Shelley.PoolRank.LogWeight
instance GHC.Generics.Generic Cardano.Ledger.Shelley.PoolRank.LogWeight
instance GHC.Classes.Eq Cardano.Ledger.Shelley.PoolRank.LogWeight
instance GHC.Generics.Generic Cardano.Ledger.Shelley.PoolRank.Histogram
instance GHC.Show.Show Cardano.Ledger.Shelley.PoolRank.Histogram
instance GHC.Classes.Eq Cardano.Ledger.Shelley.PoolRank.Histogram
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Shelley.PoolRank.Likelihood
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Shelley.PoolRank.Likelihood
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Generics.Generic Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Classes.Ord Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Show.Show Cardano.Ledger.Shelley.PoolRank.Likelihood
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance GHC.Generics.Generic Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance GHC.Classes.Eq Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance GHC.Show.Show Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.PoolRank.NonMyopic c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.PoolRank.NonMyopic c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.PoolRank.NonMyopic c)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.PoolRank.NonMyopic c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PoolRank.NonMyopic c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.PoolRank.NonMyopic c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.PoolRank.NonMyopic c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.Sharing.DecShareCBOR (Cardano.Ledger.Shelley.PoolRank.NonMyopic c)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.PoolRank.NonMyopic crypto)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.PoolRank.NonMyopic c)
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Classes.Eq Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Base.Semigroup Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Base.Monoid Cardano.Ledger.Shelley.PoolRank.Likelihood
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.PoolRank.Likelihood
instance Data.TreeDiff.Class.ToExpr Cardano.Ledger.Shelley.PoolRank.Likelihood
instance Data.TreeDiff.Class.ToExpr Cardano.Ledger.Shelley.PoolRank.LogWeight


-- | How to compute the reward update compuation. Also, how to spread the
--   compuation over many blocks, once the chain reaches a stability point.
module Cardano.Ledger.Shelley.RewardUpdate
type RewardEvent c = Map (Credential 'Staking c) (Set (Reward c))

-- | The result of reward calculation is a pair of aggregate Maps. One for
--   the accumulated answer, and one for the answer since the last pulse
data RewardAns c
RewardAns :: !Map (Credential 'Staking c) (Reward c) -> !RewardEvent c -> RewardAns c
[accumRewardAns] :: RewardAns c -> !Map (Credential 'Staking c) (Reward c)
[recentRewardAns] :: RewardAns c -> !RewardEvent c

-- | The type of RewardPulser we pulse on.
type Pulser c = RewardPulser c ShelleyBase (RewardAns c)

-- | The ultiate goal of a reward update computation. Aggregating rewards
--   for each staking credential.
data RewardUpdate c
RewardUpdate :: !DeltaCoin -> !DeltaCoin -> !Map (Credential 'Staking c) (Set (Reward c)) -> !DeltaCoin -> !NonMyopic c -> RewardUpdate c
[deltaT] :: RewardUpdate c -> !DeltaCoin
[deltaR] :: RewardUpdate c -> !DeltaCoin
[rs] :: RewardUpdate c -> !Map (Credential 'Staking c) (Set (Reward c))
[deltaF] :: RewardUpdate c -> !DeltaCoin
[nonMyopic] :: RewardUpdate c -> !NonMyopic c
emptyRewardUpdate :: RewardUpdate c

-- | To complete the reward update, we need a snap shot of the EpochState
--   particular to this computation
data RewardSnapShot c
RewardSnapShot :: !Coin -> !ProtVer -> !NonMyopic c -> !Coin -> !Coin -> !Coin -> !Map (KeyHash 'StakePool c) Likelihood -> !Map (Credential 'Staking c) (Set (Reward c)) -> RewardSnapShot c
[rewFees] :: RewardSnapShot c -> !Coin
[rewProtocolVersion] :: RewardSnapShot c -> !ProtVer
[rewNonMyopic] :: RewardSnapShot c -> !NonMyopic c
[rewDeltaR1] :: RewardSnapShot c -> !Coin
[rewR] :: RewardSnapShot c -> !Coin
[rewDeltaT1] :: RewardSnapShot c -> !Coin
[rewLikelihoods] :: RewardSnapShot c -> !Map (KeyHash 'StakePool c) Likelihood
[rewLeaders] :: RewardSnapShot c -> !Map (Credential 'Staking c) (Set (Reward c))
data FreeVars c
FreeVars :: !VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c) -> !Set (Credential 'Staking c) -> !Coin -> !ProtVer -> !Map (KeyHash 'StakePool c) (PoolRewardInfo c) -> FreeVars c
[fvDelegs] :: FreeVars c -> !VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c)
[fvAddrsRew] :: FreeVars c -> !Set (Credential 'Staking c)
[fvTotalStake] :: FreeVars c -> !Coin
[fvProtVer] :: FreeVars c -> !ProtVer
[fvPoolRewardInfo] :: FreeVars c -> !Map (KeyHash 'StakePool c) (PoolRewardInfo c)

-- | The function to call on each reward update pulse. Called by the
--   pulser.
rewardStakePoolMember :: FreeVars c -> RewardAns c -> Credential 'Staking c -> CompactForm Coin -> RewardAns c

-- | The type of a Pulser which uses <a>rewardStakePoolMember</a> as its
--   underlying function. <tt>rewardStakePool</tt> will be partially
--   applied to the component of type (FreeVars c) when pulsing. Note that
--   we use two type equality (~) constraints to fix both the monad
--   <tt>m</tt> and the <tt>ans</tt> type, to the context where we will use
--   the type as a Pulser. The type must have <tt>m</tt> and <tt>ans</tt>
--   as its last two parameters so we can make a Pulsable instance. RSPL =
--   Reward Serializable Listbased Pulser
data RewardPulser c (m :: Type -> Type) ans
[RSLP] :: (ans ~ RewardAns c, m ~ ShelleyBase) => !Int -> !FreeVars c -> !VMap VB VP (Credential 'Staking c) (CompactForm Coin) -> !ans -> RewardPulser c m ans
clearRecent :: RewardAns c -> RewardAns c

-- | The state used in the STS rules
data PulsingRewUpdate c
Pulsing :: !RewardSnapShot c -> !Pulser c -> PulsingRewUpdate c
Complete :: !RewardUpdate c -> PulsingRewUpdate c
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot c)
instance Data.Typeable.Internal.Typeable c => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.FreeVars c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardUpdate.FreeVars c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.FreeVars c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.FreeVars c)
instance Data.Typeable.Internal.Typeable c => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate c)
instance GHC.Classes.Eq ans => GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.RewardPulser c m ans)
instance GHC.Show.Show ans => GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.RewardPulser c m ans)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate c)
instance Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate c)
instance Data.Typeable.Internal.Typeable c => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.Pulser c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.Pulser c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.RewardUpdate.Pulser c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.RewardUpdate.Pulser c)
instance Data.Pulse.Pulsable (Cardano.Ledger.Shelley.RewardUpdate.RewardPulser c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.FreeVars c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.RewardUpdate.FreeVars c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.RewardUpdate.FreeVars c)
instance Data.Typeable.Internal.Typeable c => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)

module Cardano.Ledger.Shelley.Genesis

-- | Genesis Shelley staking configuration.
--   
--   This allows us to configure some initial stake pools and delegation to
--   them, in order to test Praos in a static configuration, without
--   requiring on-chain registration and delegation.
--   
--   For simplicity, pools defined in the genesis staking do not pay
--   deposits for their registration.
data ShelleyGenesisStaking c
ShelleyGenesisStaking :: ListMap (KeyHash 'StakePool c) (PoolParams c) -> ListMap (KeyHash 'Staking c) (KeyHash 'StakePool c) -> ShelleyGenesisStaking c

-- | Pools to register
--   
--   The key in this map is the hash of the public key of the _pool_. This
--   need not correspond to any payment or staking key, but must correspond
--   to the cold key held by <tt>TPraosIsCoreNode</tt>.
[sgsPools] :: ShelleyGenesisStaking c -> ListMap (KeyHash 'StakePool c) (PoolParams c)

-- | Stake-holding key hash credentials and the pools to delegate that
--   stake to. We require the raw staking key hash in order to:
--   
--   <ul>
--   <li>Avoid pointer addresses, which would be tricky when there's no
--   slot or transaction to point to.</li>
--   <li>Avoid script credentials.</li>
--   </ul>
[sgsStake] :: ShelleyGenesisStaking c -> ListMap (KeyHash 'Staking c) (KeyHash 'StakePool c)

-- | Shelley genesis information
--   
--   Note that this is needed only for a pure Shelley network, hence it
--   being defined here rather than in its own module. In mainnet, Shelley
--   will transition naturally from Byron, and thus will never have its own
--   genesis information.
data ShelleyGenesis c
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTimeMicro -> !Word64 -> !Word64 -> !PParams (ShelleyEra c) -> !Map (KeyHash 'Genesis c) (GenDelegPair c) -> ListMap (Addr c) Coin -> ShelleyGenesisStaking c -> ShelleyGenesis c
[sgSystemStart] :: ShelleyGenesis c -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis c -> !Word32
[sgNetworkId] :: ShelleyGenesis c -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis c -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis c -> !Word64
[sgEpochLength] :: ShelleyGenesis c -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis c -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis c -> !Word64
[sgSlotLength] :: ShelleyGenesis c -> !NominalDiffTimeMicro
[sgUpdateQuorum] :: ShelleyGenesis c -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis c -> !Word64
[sgProtocolParams] :: ShelleyGenesis c -> !PParams (ShelleyEra c)
[sgGenDelegs] :: ShelleyGenesis c -> !Map (KeyHash 'Genesis c) (GenDelegPair c)

-- | <a>sgInitialFunds</a> is intentionally kept lazy, as it can otherwise
--   cause out-of-memory problems in testing and benchmarking.
[sgInitialFunds] :: ShelleyGenesis c -> ListMap (Addr c) Coin

-- | <a>sgStaking</a> is intentionally kept lazy, as it can otherwise cause
--   out-of-memory problems in testing and benchmarking.
[sgStaking] :: ShelleyGenesis c -> ShelleyGenesisStaking c
toShelleyGenesisPairs :: (KeyValue a, Crypto c) => ShelleyGenesis c -> [a]
data ValidationErr
EpochNotLongEnough :: EpochSize -> Word64 -> Rational -> EpochSize -> ValidationErr
MaxKESEvolutionsUnsupported :: Word64 -> Word -> ValidationErr
QuorumTooSmall :: Word64 -> Word64 -> Word64 -> ValidationErr

-- | Unlike <tt><a>NominalDiffTime</a></tt> that supports
--   <tt><a>Pico</a></tt> precision, this type only supports
--   <tt><a>Micro</a></tt> precision.
newtype NominalDiffTimeMicro
NominalDiffTimeMicro :: Micro -> NominalDiffTimeMicro

-- | Empty genesis staking
emptyGenesisStaking :: ShelleyGenesisStaking c
sgActiveSlotCoeff :: ShelleyGenesis c -> ActiveSlotCoeff
genesisUTxO :: forall era. EraTxOut era => ShelleyGenesis (EraCrypto era) -> UTxO era

-- | Compute the <a>TxIn</a> of the initial UTxO pseudo-transaction
--   corresponding to the given address in the genesis initial funds.
--   
--   The Shelley initial UTxO is constructed from the <a>sgInitialFunds</a>
--   which is not a full UTxO but just a map from addresses to coin values.
--   
--   This gets turned into a UTxO by making a pseudo-transaction for each
--   address, with the 0th output being the coin value. So to spend from
--   the initial UTxO we need this same <a>TxIn</a> to use as an input to
--   the spending transaction.
initialFundsPseudoTxIn :: forall c. Crypto c => Addr c -> TxIn c

-- | Do some basic sanity checking on the Shelley genesis file.
validateGenesis :: forall c. Crypto c => ShelleyGenesis c -> Either [ValidationErr] ()
describeValidationErr :: ValidationErr -> Text
mkShelleyGlobals :: ShelleyGenesis c -> EpochInfo (Either Text) -> Version -> Globals
nominalDiffTimeMicroToMicroseconds :: NominalDiffTimeMicro -> Micro
nominalDiffTimeMicroToSeconds :: NominalDiffTimeMicro -> Pico
toNominalDiffTimeMicro :: NominalDiffTime -> Maybe NominalDiffTimeMicro
toNominalDiffTimeMicroWithRounding :: NominalDiffTime -> NominalDiffTimeMicro
fromNominalDiffTimeMicro :: NominalDiffTimeMicro -> NominalDiffTime
secondsToNominalDiffTimeMicro :: Micro -> NominalDiffTimeMicro
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking c)
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance GHC.Real.Real Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance GHC.Real.Fractional Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance GHC.Num.Num Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance GHC.Classes.Ord Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance GHC.Generics.Generic Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance GHC.Classes.Eq Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance GHC.Show.Show Cardano.Ledger.Shelley.Genesis.NominalDiffTimeMicro
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis c)
instance GHC.Show.Show Cardano.Ledger.Shelley.Genesis.ValidationErr
instance GHC.Classes.Eq Cardano.Ledger.Shelley.Genesis.ValidationErr
instance Cardano.Ledger.Crypto.Crypto c => GHC.Show.Show (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis c)
instance Cardano.Ledger.Crypto.Crypto c => GHC.Classes.Eq (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis c)
instance Cardano.Ledger.Crypto.Crypto c => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking c)
instance GHC.Base.Semigroup (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking c)
instance GHC.Base.Monoid (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking c)

module Cardano.Ledger.Shelley.Translation

-- | Required data to translate a Byron ledger into a Shelley ledger.
data FromByronTranslationContext c
FromByronTranslationContext :: !Map (KeyHash 'Genesis c) (GenDelegPair c) -> !PParams (ShelleyEra c) -> !Word64 -> FromByronTranslationContext c
[fbtcGenDelegs] :: FromByronTranslationContext c -> !Map (KeyHash 'Genesis c) (GenDelegPair c)
[fbtcProtocolParams] :: FromByronTranslationContext c -> !PParams (ShelleyEra c)
[fbtcMaxLovelaceSupply] :: FromByronTranslationContext c -> !Word64

-- | Trivial FromByronTranslationContext value, for use in cases where we
--   do not need to translate from Byron to Shelley.
emptyFromByronTranslationContext :: Crypto c => FromByronTranslationContext c
toFromByronTranslationContext :: ShelleyGenesis c -> FromByronTranslationContext c
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Translation.FromByronTranslationContext c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Translation.FromByronTranslationContext c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Translation.FromByronTranslationContext c)
instance Cardano.Ledger.Crypto.Crypto c => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Translation.FromByronTranslationContext c)

module Cardano.Ledger.Shelley.Delegation.PoolParams

-- | <i>Deprecated: Use accessor functions directly <a>ppCost</a>,
--   <a>ppMargin</a> and <a>ppPledge</a></i>
poolSpec :: PoolParams c -> (Coin, UnitInterval, Coin)

module Cardano.Ledger.Shelley.AdaPots
data AdaPots
AdaPots :: Coin -> Coin -> Coin -> Coin -> Coin -> Coin -> Coin -> Coin -> AdaPots
[treasuryAdaPot] :: AdaPots -> Coin
[reservesAdaPot] :: AdaPots -> Coin
[rewardsAdaPot] :: AdaPots -> Coin
[utxoAdaPot] :: AdaPots -> Coin
[keyDepositAdaPot] :: AdaPots -> Coin
[poolDepositAdaPot] :: AdaPots -> Coin
[depositsAdaPot] :: AdaPots -> Coin
[feesAdaPot] :: AdaPots -> Coin

-- | Calculate the total ada in the epoch state
totalAdaES :: EraTxOut era => EpochState era -> Coin

-- | Calculate the total ada pots in the epoch state
totalAdaPotsES :: EraTxOut era => EpochState era -> AdaPots

-- | Itemizing what is Produced by a transaction
data Produced
Produced :: !Coin -> !Coin -> !Coin -> Produced
[proOutputs] :: Produced -> !Coin
[proFees] :: Produced -> !Coin
[proDeposits] :: Produced -> !Coin

-- | Itemizing what is consumed by a transaction
data Consumed
Consumed :: !Coin -> !Coin -> !Coin -> Consumed
[conInputs] :: Consumed -> !Coin
[conRefunds] :: Consumed -> !Coin
[conWithdrawals] :: Consumed -> !Coin

-- | Compute the Coin part of what is consumed by a TxBody, itemized as a
--   <tt>Consume</tt>
consumedTxBody :: ShelleyEraTxBody era => TxBody era -> PParams era -> CertState era -> UTxO era -> Consumed

-- | Compute the Coin part of what is produced by a TxBody, itemized as a
--   <a>Produced</a>
producedTxBody :: ShelleyEraTxBody era => TxBody era -> PParams era -> CertState era -> Produced
instance GHC.Classes.Eq Cardano.Ledger.Shelley.AdaPots.AdaPots
instance GHC.Show.Show Cardano.Ledger.Shelley.AdaPots.AdaPots
instance GHC.Show.Show Cardano.Ledger.Shelley.AdaPots.Produced
instance GHC.Show.Show Cardano.Ledger.Shelley.AdaPots.Consumed


-- | Tools for reporting things in readable manner. Used in Rules to
--   implement STS <tt>renderAssertionViolation</tt> methods, and in Tests.
module Cardano.Ledger.Shelley.Rules.Reports
showCred :: Credential x c -> String
showIR :: InstantaneousRewards c -> String
showKeyHash :: KeyHash c x -> String
showListy :: Foldable t => (a -> String) -> t a -> String
showMap :: (t1 -> [Char]) -> (t2 -> [Char]) -> Map t1 t2 -> String
showWithdrawal :: Withdrawals c -> String
showSafeHash :: SafeHash c i -> String
synopsisCert :: ShelleyEraTxCert era => TxCert era -> String

-- | Display a synopsis of a map to Coin
synopsisCoinMap :: Maybe (Map k Coin) -> String
showTxCerts :: ShelleyEraTxBody era => TxBody era -> String
produceEqualsConsumed :: ShelleyEraTxBody era => PParams era -> CertState era -> UTxO era -> TxBody era -> String

module Cardano.Ledger.Shelley.TxWits
keyBy :: Ord k => (a -> k) -> [a] -> Map k a
decodeWits :: forall era s. EraScript era => Decoder s (Annotator (ShelleyTxWits era))
data ShelleyTxWits era
pattern ShelleyTxWits :: forall era. EraScript era => Set (WitVKey 'Witness (EraCrypto era)) -> Map (ScriptHash (EraCrypto era)) (Script era) -> Set (BootstrapWitness (EraCrypto era)) -> ShelleyTxWits era
data WitnessSetHKD f era

-- | Script witness setter and getter for <a>ShelleyTxWits</a>. The setter
--   does update memoized binary representation.
scriptShelleyTxWitsL :: EraScript era => Lens' (ShelleyTxWits era) (Map (ScriptHash (EraCrypto era)) (Script era))

-- | Addresses witness setter and getter for <a>ShelleyTxWits</a>. The
--   setter does update memoized binary representation.
addrShelleyTxWitsL :: EraScript era => Lens' (ShelleyTxWits era) (Set (WitVKey 'Witness (EraCrypto era)))

-- | Bootstrap Addresses witness setter and getter for
--   <a>ShelleyTxWits</a>. The setter does update memoized binary
--   representation.
bootAddrShelleyTxWitsL :: EraScript era => Lens' (ShelleyTxWits era) (Set (BootstrapWitness (EraCrypto era)))
addrWits' :: WitnessSetHKD f era -> HKD f (Set (WitVKey 'Witness (EraCrypto era)))

-- | Exports the relevant parts from a (WintessSetHKD Identity era) for use
--   by the pretty printer without all the horrible constraints. Uses the
--   non-exported WitnessSet' constructor.
prettyWitnessSetParts :: ShelleyTxWits era -> (Set (WitVKey 'Witness (EraCrypto era)), Map (ScriptHash (EraCrypto era)) (Script era), Set (BootstrapWitness (EraCrypto era)))
shelleyEqTxWitsRaw :: EraTxWits era => TxWits era -> TxWits era -> Bool
data () => WitVKey (kr :: KeyRole) c
pattern WitVKey :: (Typeable kr, Crypto c) => VKey kr c -> SignedDSIGN c (Hash c EraIndependentTxBody) -> WitVKey kr c
instance Cardano.Ledger.Crypto.Crypto c => GHC.Classes.Eq (Cardano.Ledger.Shelley.TxWits.IgnoreSigOrd kr c)
instance Cardano.Ledger.Core.EraScript era => GHC.Show.Show (Cardano.Ledger.Shelley.TxWits.WitnessSetHKD Data.Functor.Identity.Identity era)
instance Cardano.Ledger.Core.EraScript era => GHC.Classes.Eq (Cardano.Ledger.Shelley.TxWits.WitnessSetHKD Data.Functor.Identity.Identity era)
instance Cardano.Ledger.Core.Era.Era era => GHC.Generics.Generic (Cardano.Ledger.Shelley.TxWits.WitnessSetHKD Data.Functor.Identity.Identity era)
instance (Cardano.Ledger.Core.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.Script era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxWits.WitnessSetHKD Data.Functor.Identity.Identity era)
instance Cardano.Ledger.Core.EraScript era => GHC.Classes.Eq (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance Cardano.Ledger.Core.EraScript era => GHC.Show.Show (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance Cardano.Ledger.Core.Era.Era era => GHC.Generics.Generic (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto c) => GHC.Classes.Ord (Cardano.Ledger.Shelley.TxWits.IgnoreSigOrd kr c)
instance (Cardano.Ledger.Core.Era.Era era, Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.Script era)) => Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance (Cardano.Ledger.Core.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.Script era), Control.DeepSeq.NFData (Cardano.Ledger.Keys.WitVKey.WitVKey 'Cardano.Ledger.Keys.Witness (Cardano.Ledger.Core.Era.EraCrypto era)), Control.DeepSeq.NFData (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness (Cardano.Ledger.Core.Era.EraCrypto era))) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance (Cardano.Ledger.Core.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.Script era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Core.EraTxWits (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance (Cardano.Ledger.Core.TxWits era GHC.Types.~ Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era, Cardano.Ledger.Core.EraTxWits era) => Cardano.Ledger.MemoBytes.EqRaw (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance Cardano.Ledger.Core.EraScript era => GHC.Base.Semigroup (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance Cardano.Ledger.Core.EraScript era => GHC.Base.Monoid (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era)
instance Cardano.Ledger.Core.EraScript era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Shelley.TxWits.ShelleyTxWits era))
instance (Cardano.Ledger.Core.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.Script era), Control.DeepSeq.NFData (Cardano.Ledger.Keys.WitVKey.WitVKey 'Cardano.Ledger.Keys.Witness (Cardano.Ledger.Core.Era.EraCrypto era)), Control.DeepSeq.NFData (Cardano.Ledger.Keys.Bootstrap.BootstrapWitness (Cardano.Ledger.Core.Era.EraCrypto era))) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxWits.WitnessSetHKD Data.Functor.Identity.Identity era)

module Cardano.Ledger.Shelley.Tx
data ShelleyTx era
pattern ShelleyTx :: EraTx era => TxBody era -> TxWits era -> StrictMaybe (TxAuxData era) -> ShelleyTx era

-- | <a>TxBody</a> setter and getter for <a>ShelleyTx</a>. The setter does
--   update memoized binary representation.
bodyShelleyTxL :: EraTx era => Lens' (ShelleyTx era) (TxBody era)

-- | <a>TxWits</a> setter and getter for <a>ShelleyTx</a>. The setter does
--   update memoized binary representation.
witsShelleyTxL :: EraTx era => Lens' (ShelleyTx era) (TxWits era)

-- | <a>TxAuxData</a> setter and getter for <a>ShelleyTx</a>. The setter
--   does update memoized binary representation.
auxDataShelleyTxL :: EraTx era => Lens' (ShelleyTx era) (StrictMaybe (TxAuxData era))

-- | Size getter for <a>ShelleyTx</a>.
sizeShelleyTxF :: Era era => SimpleGetter (ShelleyTx era) Integer
segwitTx :: forall era. EraTx era => Annotator (TxBody era) -> Annotator (TxWits era) -> Maybe (Annotator (TxAuxData era)) -> Annotator (ShelleyTx era)
mkBasicShelleyTx :: EraTx era => TxBody era -> ShelleyTx era

-- | Multi-signature script witness accessor function for Transactions
txwitsScript :: EraTx era => Tx era -> Map (ScriptHash (EraCrypto era)) (Script era)

-- | <i>Deprecated: In favor of <a>credKeyHashWitness</a></i>
extractKeyHashWitnessSet :: forall (r :: KeyRole) c. [Credential r c] -> Set (KeyHash 'Witness c)

-- | <i>Deprecated: In favor of <a>evalMultiSig</a> that has the arguments
--   flipped</i>
evalNativeMultiSigScript :: Era era => MultiSig era -> Set (KeyHash 'Witness (EraCrypto era)) -> Bool

-- | Hashes native multi-signature script.
hashMultiSigScript :: forall era. (EraScript era, Script era ~ MultiSig (EraCrypto era)) => MultiSig (EraCrypto era) -> ScriptHash (EraCrypto era)

-- | Magic number "memorialized" in the ValidateScript class under the
--   method: scriptPrefixTag:: Core.Script era -&gt; Bs.ByteString, for the
--   Shelley Era.
nativeMultiSigTag :: ByteString

-- | Script validator for native multi-signature scheme.

-- | <i>Deprecated: In favor of <a>validateMultiSig</a> that has the
--   arguments flipped</i>
validateNativeMultiSigScript :: EraTx era => MultiSig era -> Tx era -> Bool

-- | <i>Deprecated: In favor of <a>getMinFeeTx</a></i>
minfee :: EraTx era => PParams era -> Tx era -> Coin

-- | Minimum fee calculation
shelleyMinFeeTx :: EraTx era => PParams era -> Tx era -> Coin

-- | Extract the witness hashes from the Transaction.
witsFromTxWitnesses :: EraTx era => Tx era -> Set (KeyHash 'Witness (EraCrypto era))
shelleyEqTxRaw :: EraTx era => Tx era -> Tx era -> Bool
newtype ShelleyTxBody era
TxBodyConstr :: MemoBytes ShelleyTxBodyRaw era -> ShelleyTxBody era

-- | Pattern for use by external users
pattern ShelleyTxBody :: (EraTxOut era, EncCBOR (TxCert era)) => Set (TxIn (EraCrypto era)) -> StrictSeq (TxOut era) -> StrictSeq (TxCert era) -> Withdrawals (EraCrypto era) -> Coin -> SlotNo -> StrictMaybe (Update era) -> StrictMaybe (AuxiliaryDataHash (EraCrypto era)) -> ShelleyTxBody era
data ShelleyTxOut era
TxOutCompact :: {-# UNPACK #-} !CompactAddr (EraCrypto era) -> !CompactForm (Value era) -> ShelleyTxOut era
pattern ShelleyTxOut :: (HasCallStack, Era era, Val (Value era)) => Addr (EraCrypto era) -> Value era -> ShelleyTxOut era
data () => TxIn c
TxIn :: !TxId c -> {-# UNPACK #-} !TxIx -> TxIn c
newtype () => TxId c
TxId :: SafeHash c EraIndependentTxBody -> TxId c
[unTxId] :: TxId c -> SafeHash c EraIndependentTxBody
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Tx.ShelleyTxRaw era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Tx.ShelleyTx era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Tx.ShelleyTx era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Shelley.Tx.ShelleyTx era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Core.TxBody era), GHC.Classes.Eq (Cardano.Ledger.Core.TxWits era), GHC.Classes.Eq (Cardano.Ledger.Core.TxAuxData era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Tx.ShelleyTxRaw era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.TxBody era), GHC.Show.Show (Cardano.Ledger.Core.TxWits era), GHC.Show.Show (Cardano.Ledger.Core.TxAuxData era)) => GHC.Show.Show (Cardano.Ledger.Shelley.Tx.ShelleyTxRaw era)
instance (Control.DeepSeq.NFData (Cardano.Ledger.Core.TxBody era), Control.DeepSeq.NFData (Cardano.Ledger.Core.TxWits era), Control.DeepSeq.NFData (Cardano.Ledger.Core.TxAuxData era)) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Tx.ShelleyTx era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Core.TxBody era), GHC.Classes.Eq (Cardano.Ledger.Core.TxWits era), GHC.Classes.Eq (Cardano.Ledger.Core.TxAuxData era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Tx.ShelleyTx era)
instance (Cardano.Ledger.Core.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.TxBody era), GHC.Show.Show (Cardano.Ledger.Core.TxWits era), GHC.Show.Show (Cardano.Ledger.Core.TxAuxData era)) => GHC.Show.Show (Cardano.Ledger.Shelley.Tx.ShelleyTx era)
instance (Cardano.Ledger.Core.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxAuxData era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxBody era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxWits era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Tx.ShelleyTx era)
instance Cardano.Ledger.Core.EraTx era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Shelley.Tx.ShelleyTx era))
instance Cardano.Ledger.MemoBytes.Memoized Cardano.Ledger.Shelley.Tx.ShelleyTx
instance (Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.TxAuxData era), Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.TxBody era), Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.TxWits era)) => Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.Tx.ShelleyTx era)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Core.EraTx (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance (Cardano.Ledger.Core.Tx era GHC.Types.~ Cardano.Ledger.Shelley.Tx.ShelleyTx era, Cardano.Ledger.Core.EraTx era) => Cardano.Ledger.MemoBytes.EqRaw (Cardano.Ledger.Shelley.Tx.ShelleyTx era)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.Tx.ShelleyTx era)
instance (Control.DeepSeq.NFData (Cardano.Ledger.Core.TxBody era), Control.DeepSeq.NFData (Cardano.Ledger.Core.TxWits era), Control.DeepSeq.NFData (Cardano.Ledger.Core.TxAuxData era)) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Tx.ShelleyTxRaw era)
instance (Cardano.Ledger.Core.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxAuxData era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxBody era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxWits era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Tx.ShelleyTxRaw era)
instance (Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.TxAuxData era), Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.TxBody era), Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Core.TxWits era)) => Data.TreeDiff.Class.ToExpr (Cardano.Ledger.Shelley.Tx.ShelleyTxRaw era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.TxWits era), Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.TxBody era), Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Core.TxAuxData era)) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.Tx.ShelleyTxRaw era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Core.TxBody era)), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Core.TxWits era)), Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Core.TxAuxData era))) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Shelley.Tx.ShelleyTxRaw era))

module Cardano.Ledger.Shelley.BlockChain
data ShelleyTxSeq era
TxSeq' :: !StrictSeq (ShelleyTx era) -> ByteString -> ByteString -> ByteString -> ShelleyTxSeq era

-- | Constuct a TxSeq (with all it bytes) from just Tx's
pattern ShelleyTxSeq :: forall era. (EraTx era, Tx era ~ ShelleyTx era, SafeToHash (TxWits era)) => StrictSeq (Tx era) -> ShelleyTxSeq era

-- | Given a size and a mapping from indices to maybe metadata, return a
--   sequence whose size is the size paramater and whose non-Nothing values
--   correspond to the values in the mapping.
constructMetadata :: forall era. Int -> Map Int (Annotator (TxAuxData era)) -> Seq (Maybe (Annotator (TxAuxData era)))
txSeqTxns :: ShelleyTxSeq era -> StrictSeq (ShelleyTx era)

-- | Hash a given block body
bbHash :: forall era. Era era => ShelleyTxSeq era -> Hash (EraCrypto era) EraIndependentBlockBody
bBodySize :: EraSegWits era => ProtVer -> TxSeq era -> Int
slotToNonce :: SlotNo -> Nonce
incrBlocks :: Bool -> KeyHash 'StakePool c -> BlocksMade c -> BlocksMade c
coreAuxDataBytes :: EraTx era => Tx era -> StrictMaybe ByteString

-- | The parts of the Tx in Blocks that have to have DecCBOR(Annotator x)
--   instances. These are exactly the parts that are SafeToHash. | Decode a
--   TxSeq, used in decoding a Block.
txSeqDecoder :: forall era. EraTx era => Bool -> forall s. Decoder s (Annotator (ShelleyTxSeq era))
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.BlockChain.ShelleyTxSeq era)
instance (Data.Typeable.Internal.Typeable era, NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Tx.ShelleyTx era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.BlockChain.ShelleyTxSeq era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Tx.ShelleyTx era) => GHC.Show.Show (Cardano.Ledger.Shelley.BlockChain.ShelleyTxSeq era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Tx.ShelleyTx era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.BlockChain.ShelleyTxSeq era)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Core.EraSegWits (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance Cardano.Ledger.Core.Era.Era era => Cardano.Ledger.Binary.Group.EncCBORGroup (Cardano.Ledger.Shelley.BlockChain.ShelleyTxSeq era)
instance Cardano.Ledger.Core.EraTx era => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Binary.Decoding.Annotated.Annotator (Cardano.Ledger.Shelley.BlockChain.ShelleyTxSeq era))

module Cardano.Ledger.Shelley.UTxO
class EraTx era => EraUTxO era where {
    type family ScriptsNeeded era = (r :: Type) | r -> era;
}
getConsumedValue :: EraUTxO era => PParams era -> (Credential 'Staking (EraCrypto era) -> Maybe Coin) -> (Credential 'DRepRole (EraCrypto era) -> Maybe Coin) -> UTxO era -> TxBody era -> Value era
getProducedValue :: EraUTxO era => PParams era -> (KeyHash 'StakePool (EraCrypto era) -> Bool) -> TxBody era -> Value era
getScriptsProvided :: EraUTxO era => UTxO era -> Tx era -> ScriptsProvided era
getScriptsNeeded :: EraUTxO era => UTxO era -> TxBody era -> ScriptsNeeded era
getScriptsHashesNeeded :: EraUTxO era => ScriptsNeeded era -> Set (ScriptHash (EraCrypto era))
newtype ShelleyScriptsNeeded era
ShelleyScriptsNeeded :: Set (ScriptHash (EraCrypto era)) -> ShelleyScriptsNeeded era

-- | Computes the set of script hashes required to unlock the transaction
--   inputs and the withdrawals.

-- | <i>Deprecated: In favor of <a>getScriptsNeeded</a></i>
scriptsNeeded :: forall era. (EraTx era, ShelleyEraTxBody era) => UTxO era -> Tx era -> Set (ScriptHash (EraCrypto era))
getShelleyScriptsNeeded :: ShelleyEraTxBody era => UTxO era -> TxBody era -> ShelleyScriptsNeeded era

-- | <i>Deprecated: In favor of <a>credScriptHash</a></i>
scriptCred :: Credential kr c -> Maybe (ScriptHash c)

-- | <i>Deprecated: In favor of <a>getScriptWitnessTxCert</a></i>
scriptStakeCred :: ShelleyEraTxCert era => TxCert era -> Maybe (ScriptHash (EraCrypto era))

-- | Compute the lovelace which are destroyed by the transaction
getConsumedCoin :: ShelleyEraTxBody era => PParams era -> (Credential 'Staking (EraCrypto era) -> Maybe Coin) -> UTxO era -> TxBody era -> Coin
shelleyProducedValue :: ShelleyEraTxBody era => PParams era -> (KeyHash 'StakePool (EraCrypto era) -> Bool) -> TxBody era -> Value era

-- | For eras before Conway, VState is expected to have an empty Map for
--   vsDReps, and so deposit summed up is zero.
consumed :: EraUTxO era => PParams era -> CertState era -> UTxO era -> TxBody era -> Value era

-- | Compute the lovelace which are created by the transaction For eras
--   before Conway, VState is expected to have an empty Map for vsDReps,
--   and so deposit summed up is zero.
produced :: EraUTxO era => PParams era -> CertState era -> TxBody era -> Value era
txup :: (EraTx era, ShelleyEraTxBody era, ProtVerAtMost era 8) => Tx era -> Maybe (Update era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.UTxO.ShelleyScriptsNeeded era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.UTxO.ShelleyScriptsNeeded era)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.UTxO.EraUTxO (Cardano.Ledger.Shelley.Era.ShelleyEra c)


-- | This module implements the operation rules for treating UTxO
--   transactions (<tt>Tx</tt>) as state transformations on a ledger state
--   (<a>LedgerState</a>), as specified in <i>A Simplified Formal
--   Specification of a UTxO Ledger</i>.
module Cardano.Ledger.Shelley.LedgerState
data AccountState
AccountState :: !Coin -> !Coin -> AccountState
[asTreasury] :: AccountState -> !Coin
[asReserves] :: AccountState -> !Coin
data () => CertState era
CertState :: !VState era -> !PState era -> !DState era -> CertState era
[certVState] :: CertState era -> !VState era
[certPState] :: CertState era -> !PState era
[certDState] :: CertState era -> !DState era
data () => DState era
DState :: !UMap (EraCrypto era) -> !Map (FutureGenDeleg (EraCrypto era)) (GenDelegPair (EraCrypto era)) -> !GenDelegs (EraCrypto era) -> !InstantaneousRewards (EraCrypto era) -> DState era
[dsUnified] :: DState era -> !UMap (EraCrypto era)
[dsFutureGenDelegs] :: DState era -> !Map (FutureGenDeleg (EraCrypto era)) (GenDelegPair (EraCrypto era))
[dsGenDelegs] :: DState era -> !GenDelegs (EraCrypto era)
[dsIRewards] :: DState era -> !InstantaneousRewards (EraCrypto era)
data () => VState era
VState :: !Map (Credential 'DRepRole (EraCrypto era)) (DRepState (EraCrypto era)) -> !CommitteeState era -> EpochNo -> VState era
[vsDReps] :: VState era -> !Map (Credential 'DRepRole (EraCrypto era)) (DRepState (EraCrypto era))
[vsCommitteeState] :: VState era -> !CommitteeState era
[vsNumDormantEpochs] :: VState era -> EpochNo

-- | <i>Deprecated: Use <a>def</a> instead</i>
emptyDState :: DState a
rewards :: DState era -> UView (EraCrypto era) (Credential 'Staking (EraCrypto era)) RDPair
delegations :: DState era -> UView (EraCrypto era) (Credential 'Staking (EraCrypto era)) (KeyHash 'StakePool (EraCrypto era))
ptrsMap :: DState era -> Map Ptr (Credential 'Staking (EraCrypto era))
data EpochState era
EpochState :: !AccountState -> !LedgerState era -> !SnapShots (EraCrypto era) -> !NonMyopic (EraCrypto era) -> EpochState era
[esAccountState] :: EpochState era -> !AccountState
[esLState] :: EpochState era -> !LedgerState era
[esSnapshots] :: EpochState era -> !SnapShots (EraCrypto era)

-- | This field, esNonMyopic, does not appear in the formal spec and is not
--   a part of the protocol. It is only used for providing data to the
--   stake pool ranking calculation <tt>getNonMyopicMemberRewards</tt>. See
--   <a>https://github.com/input-output-hk/cardano-ledger/releases/latest/download/pool-ranking.pdf</a>
[esNonMyopic] :: EpochState era -> !NonMyopic (EraCrypto era)

-- | The state used in the STS rules
data PulsingRewUpdate c
Pulsing :: !RewardSnapShot c -> !Pulser c -> PulsingRewUpdate c
Complete :: !RewardUpdate c -> PulsingRewUpdate c
data () => FutureGenDeleg c
FutureGenDeleg :: !SlotNo -> !KeyHash 'Genesis c -> FutureGenDeleg c
[fGenDelegSlot] :: FutureGenDeleg c -> !SlotNo
[fGenDelegGenKeyHash] :: FutureGenDeleg c -> !KeyHash 'Genesis c
data () => InstantaneousRewards c
InstantaneousRewards :: !Map (Credential 'Staking c) Coin -> !Map (Credential 'Staking c) Coin -> !DeltaCoin -> !DeltaCoin -> InstantaneousRewards c
[iRReserves] :: InstantaneousRewards c -> !Map (Credential 'Staking c) Coin
[iRTreasury] :: InstantaneousRewards c -> !Map (Credential 'Staking c) Coin
[deltaReserves] :: InstantaneousRewards c -> !DeltaCoin
[deltaTreasury] :: InstantaneousRewards c -> !DeltaCoin

-- | <i>Deprecated: Use `Test.Cardano.Ledger.Core.KeyPair (KeyPairs)`
--   instead</i>
type KeyPairs c = [(KeyPair 'Payment c, KeyPair 'Staking c)]

-- | The state associated with a <tt>Ledger</tt>.
data LedgerState era
LedgerState :: !UTxOState era -> !CertState era -> LedgerState era

-- | The current unspent transaction outputs.
[lsUTxOState] :: LedgerState era -> !UTxOState era
[lsCertState] :: LedgerState era -> !CertState era
data () => PState era
PState :: !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)) -> !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)) -> !Map (KeyHash 'StakePool (EraCrypto era)) EpochNo -> !Map (KeyHash 'StakePool (EraCrypto era)) Coin -> PState era
[psStakePoolParams] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era))
[psFutureStakePoolParams] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era))
[psRetiring] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) EpochNo
[psDeposits] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) Coin
type PPUPPredFailure era = PPUPPredFailurePV (ProtVerLow era) era
type RewardAccounts c = Map (Credential 'Staking c) Coin

-- | The ultiate goal of a reward update computation. Aggregating rewards
--   for each staking credential.
data RewardUpdate c
RewardUpdate :: !DeltaCoin -> !DeltaCoin -> !Map (Credential 'Staking c) (Set (Reward c)) -> !DeltaCoin -> !NonMyopic c -> RewardUpdate c
[deltaT] :: RewardUpdate c -> !DeltaCoin
[deltaR] :: RewardUpdate c -> !DeltaCoin
[rs] :: RewardUpdate c -> !Map (Credential 'Staking c) (Set (Reward c))
[deltaF] :: RewardUpdate c -> !DeltaCoin
[nonMyopic] :: RewardUpdate c -> !NonMyopic c

-- | To complete the reward update, we need a snap shot of the EpochState
--   particular to this computation
data RewardSnapShot c
RewardSnapShot :: !Coin -> !ProtVer -> !NonMyopic c -> !Coin -> !Coin -> !Coin -> !Map (KeyHash 'StakePool c) Likelihood -> !Map (Credential 'Staking c) (Set (Reward c)) -> RewardSnapShot c
[rewFees] :: RewardSnapShot c -> !Coin
[rewProtocolVersion] :: RewardSnapShot c -> !ProtVer
[rewNonMyopic] :: RewardSnapShot c -> !NonMyopic c
[rewDeltaR1] :: RewardSnapShot c -> !Coin
[rewR] :: RewardSnapShot c -> !Coin
[rewDeltaT1] :: RewardSnapShot c -> !Coin
[rewLikelihoods] :: RewardSnapShot c -> !Map (KeyHash 'StakePool c) Likelihood
[rewLeaders] :: RewardSnapShot c -> !Map (Credential 'Staking c) (Set (Reward c))

-- | There is a serious invariant that we must maintain in the UTxOState.
--   Given (UTxOState utxo _ _ _ istake) it must be the case that istake ==
--   (updateStakeDistribution (UTxO Map.empty) (UTxO Map.empty) utxo) Of
--   course computing the RHS of the above equality can be very expensive,
--   so we only use this route in the testing function smartUTxO. But we
--   are very careful, wherever we update the UTxO, we carefully make
--   INCREMENTAL changes to istake to maintain this invariant. This happens
--   in the UTxO rule.
data UTxOState era
UTxOState :: !UTxO era -> Coin -> !Coin -> !GovState era -> !IncrementalStake (EraCrypto era) -> !Coin -> UTxOState era
[utxosUtxo] :: UTxOState era -> !UTxO era

-- | This field is left lazy, because we only use it for assertions
[utxosDeposited] :: UTxOState era -> Coin
[utxosFees] :: UTxOState era -> !Coin
[utxosGovState] :: UTxOState era -> !GovState era
[utxosStakeDistr] :: UTxOState era -> !IncrementalStake (EraCrypto era)
[utxosDonation] :: UTxOState era -> !Coin

-- | A valid (or self-consistent) UTxOState{utxosUtxo, utxosDeposited ,
--   utxosFees , utxosPpups , utxosStakeDistr} maintains an invariant
--   between the utxosUtxo and utxosStakeDistr fields. the utxosStakeDistr
--   field is the aggregation of Coin over the StakeReferences in the UTxO.
--   It can be computed by a pure function from the _utxo field. In some
--   situations, mostly unit or example tests, or when initializing a small
--   UTxO, we want to create a UTxOState that computes the utxosStakeDistr
--   from the utxosUtxo. This is aways safe to do, but if the utxosUtxo
--   field is big, this can be very expensive, which defeats the purpose of
--   memoizing the utxosStakeDistr field. So use of this function should be
--   restricted to tests and initializations, where the invariant should be
--   maintained.
--   
--   TO IncrementalStake
smartUTxOState :: EraTxOut era => PParams era -> UTxO era -> Coin -> Coin -> GovState era -> Coin -> UTxOState era

-- | Incremental Stake, Stake along with possible missed coins from danging
--   Ptrs. Transactions can use Ptrs to refer to a stake credential in a
--   TxOut. The Ptr does not have to point to anything until the epoch
--   boundary, when we compute rewards and aggregate staking information
--   for ranking. This is unusual but legal. In a non incremental system,
--   we use whatever <tt>legal</tt> Ptrs exist at the epoch boundary. Here
--   we are computing things incrementally, so we need to remember Ptrs
--   that might point to something by the time the epoch boundary is
--   reached. When the epoch boundary is reached we <tt>resolve</tt> these
--   pointers, to see if any have become non-dangling since the time they
--   were first used in the incremental computation.
data IncrementalStake c
IStake :: !Map (Credential 'Staking c) (CompactForm Coin) -> !Map Ptr (CompactForm Coin) -> IncrementalStake c
[credMap] :: IncrementalStake c -> !Map (Credential 'Staking c) (CompactForm Coin)
[ptrMap] :: IncrementalStake c -> !Map Ptr (CompactForm Coin)

-- | Creates the ledger state for an empty ledger which contains the
--   specified transaction outputs.
genesisState :: forall era. EraGov era => Map (KeyHash 'Genesis (EraCrypto era)) (GenDelegPair (EraCrypto era)) -> UTxO era -> LedgerState era

-- | <i>Deprecated: Use a set of keyhashes instead</i>
type WitHashes era = Set (KeyHash 'Witness (EraCrypto era))

-- | <i>Deprecated: Remove this function</i>
unWitHashes :: WitHashes era -> Set (KeyHash 'Witness (EraCrypto era))

-- | <i>Deprecated: Use set operations instead</i>
nullWitHashes :: WitHashes era -> Bool

-- | <i>Deprecated: Use set operations instead</i>
diffWitHashes :: WitHashes era -> WitHashes era -> WitHashes era

-- | <i>Deprecated: In favor of <a>getMinFeeTx</a></i>
minfee :: EraTx era => PParams era -> Tx era -> Coin

-- | For eras before Conway, VState is expected to have an empty Map for
--   vsDReps, and so deposit summed up is zero.
consumed :: EraUTxO era => PParams era -> CertState era -> UTxO era -> TxBody era -> Value era

-- | Compute the lovelace which are created by the transaction For eras
--   before Conway, VState is expected to have an empty Map for vsDReps,
--   and so deposit summed up is zero.
produced :: EraUTxO era => PParams era -> CertState era -> TxBody era -> Value era

-- | Extract the witness hashes from the Transaction.
witsFromTxWitnesses :: EraTx era => Tx era -> Set (KeyHash 'Witness (EraCrypto era))
keyTxRefunds :: ShelleyEraTxBody era => PParams era -> CertState era -> TxBody era -> Coin
payPoolDeposit :: EraPParams era => KeyHash 'StakePool (EraCrypto era) -> PParams era -> PState era -> PState era
refundPoolDeposit :: KeyHash 'StakePool (EraCrypto era) -> PState era -> (Coin, PState era)

-- | <i>Deprecated: Use totalTxDepositsShelley or getTotalDepositsTxBody
--   instead</i>
totalTxDeposits :: ShelleyEraTxBody era => PParams era -> CertState era -> TxBody era -> Coin
totalObligation :: EraGov era => CertState era -> GovState era -> Coin

-- | Compute the key deregistration refunds in a transaction
keyCertsRefunds :: (EraPParams era, Foldable f, ShelleyEraTxCert era) => PParams era -> (StakeCredential (EraCrypto era) -> Maybe Coin) -> f (TxCert era) -> Coin

-- | Compute the key deregistration refunds in a transaction
keyCertsRefundsCertState :: (EraPParams era, Foldable f, ShelleyEraTxCert era) => PParams era -> CertState era -> f (TxCert era) -> Coin

-- | Determine the total deposit amount needed from a TxBody. The block may
--   (legitimately) contain multiple registration certificates for the same
--   pool, where the first will be treated as a registration and any
--   subsequent ones as re-registration. As such, we must only take a
--   deposit for the first such registration. It is even possible for a
--   single transaction to have multiple pool registration for the same
--   pool, so as we process pool registrations, we must keep track of those
--   that are already registered, so we do not add a Deposit for the same
--   pool twice.
--   
--   Note that this is not an issue for key registrations since subsequent
--   registration certificates would be invalid.
totalCertsDeposits :: (EraPParams era, Foldable f, ShelleyEraTxCert era) => PParams era -> (KeyHash 'StakePool (EraCrypto era) -> Bool) -> f (TxCert era) -> Coin
totalCertsDepositsCertState :: (EraPParams era, Foldable f, ShelleyEraTxCert era) => PParams era -> CertState era -> f (TxCert era) -> Coin

-- | This computes a Snapshot using IncrementalStake (which is an aggregate
--   of the current UTxO) and UMap (which tracks Coin, SPoolUView, and Ptrs
--   simultaneously). Note that logically: 1) IncrementalStake =
--   (credStake, ptrStake) 2) UMap = (rewards, activeDelegs, ptrmap :: Map
--   ptr cred)
--   
--   Using this scheme the logic can do 3 things in one go, without
--   touching the UTxO. 1) Resolve Pointers 2) Throw away things not
--   actively delegated 3) Add up the coin
--   
--   The Stake distribution function (Map cred coin) (the first component
--   of a SnapShot) is defined by this SetAlgebra expression: (dom
--   activeDelegs) ◁ (aggregate+ (credStake ∪ ptrStake ∪ rewards))
--   
--   We can apply meaning preserving operations to get equivalent
--   expressions
--   
--   (dom activeDelegs) ◁ (aggregate+ (credStake ∪ ptrStake ∪ rewards))
--   aggregate+ (dom activeDelegs ◁ (credStake ∪ ptrStake ∪ rewards))
--   aggregate+ ((dom activeDelegs ◁ credStake) ∪ (dom activeDelegs ◁
--   ptrStake) ∪ (dom activeDelegs ◁ rewards))
--   
--   We will compute this in several steps step1 = (dom activeDelegs ◁
--   credStake) ∪ (dom activeDelegs ◁ ptrStake) step2 = aggregate (dom
--   activeDelegs ◁ rewards) step1 This function has a non-incremental
--   analog, <tt>stakeDistr</tt>, mosty used in tests, which does use the
--   UTxO.
incrementalStakeDistr :: forall era. EraPParams era => PParams era -> IncrementalStake (EraCrypto era) -> DState era -> PState era -> SnapShot (EraCrypto era)

-- | Incrementally add the inserts <tt>utxoAdd</tt> and the deletes
--   <tt>utxoDel</tt> to the IncrementalStake.
updateStakeDistribution :: EraTxOut era => PParams era -> IncrementalStake (EraCrypto era) -> UTxO era -> UTxO era -> IncrementalStake (EraCrypto era)

-- | Apply a RewardUpdate to the EpochState. Does several things 1) Adds
--   reward coins to Rewards component of the UMap field of the DState, for
--   actively delegated Stake 2) Adds to the Treasury of the AccountState
--   for non-actively delegated stake 3) Adds fees to the UTxOState
applyRUpd :: EraGov era => RewardUpdate (EraCrypto era) -> EpochState era -> EpochState era
applyRUpdFiltered :: EraGov era => RewardUpdate (EraCrypto era) -> EpochState era -> (EpochState era, FilteredRewards era)
filterAllRewards :: EraGov era => Map (Credential 'Staking (EraCrypto era)) (Set (Reward (EraCrypto era))) -> EpochState era -> FilteredRewards era
data FilteredRewards era
FilteredRewards :: !Map (Credential 'Staking (EraCrypto era)) (Set (Reward (EraCrypto era))) -> Map (Credential 'Staking (EraCrypto era)) (Set (Reward (EraCrypto era))) -> Set (Credential 'Staking (EraCrypto era)) -> Coin -> FilteredRewards era

-- | These are registered, in the current Unified map of the CertState
[frRegistered] :: FilteredRewards era -> !Map (Credential 'Staking (EraCrypto era)) (Set (Reward (EraCrypto era)))

-- | These are registered, but ignored in the ShelleyEra because of
--   backward compatibility in non-Shelley Eras, this field will be
--   Map.empty
[frShelleyIgnored] :: FilteredRewards era -> Map (Credential 'Staking (EraCrypto era)) (Set (Reward (EraCrypto era)))

-- | These are NOT registered in the current Unified map of the CertState
[frUnregistered] :: FilteredRewards era -> Set (Credential 'Staking (EraCrypto era))

-- | Total Coin of the unregistered rewards. These will end up in the
--   Treasury or Reserves.
[frTotalUnregistered] :: FilteredRewards era -> Coin

-- | To create a reward update, run all 3 phases This function is not used
--   in the rules, so it ignores RewardEvents
createRUpd :: forall era. EraGov era => EpochSize -> BlocksMade (EraCrypto era) -> EpochState era -> Coin -> ActiveSlotCoeff -> Word64 -> ShelleyBase (RewardUpdate (EraCrypto era))

-- | Phase 3 of reward update has several parts a) completeM the pulser (in
--   case there are still computions to run) b) Combine the pulser
--   provenance with the RewardProvenance c) Construct the final
--   RewardUpdate d) Add the leader rewards to both the events and the
--   computed Rewards
completeRupd :: PulsingRewUpdate c -> ShelleyBase (RewardUpdate c, RewardEvent c)
startStep :: forall era. EraGov era => EpochSize -> BlocksMade (EraCrypto era) -> EpochState era -> Coin -> ActiveSlotCoeff -> Word64 -> PulsingRewUpdate (EraCrypto era)

-- | Run the pulser for a bit. If is has nothing left to do, complete it.
pulseStep :: PulsingRewUpdate c -> ShelleyBase (PulsingRewUpdate c, RewardEvent c)
completeStep :: PulsingRewUpdate c -> ShelleyBase (PulsingRewUpdate c, RewardEvent c)

-- | New Epoch state and environment
data NewEpochState era
NewEpochState :: !EpochNo -> !BlocksMade (EraCrypto era) -> !BlocksMade (EraCrypto era) -> !EpochState era -> !StrictMaybe (PulsingRewUpdate (EraCrypto era)) -> !PoolDistr (EraCrypto era) -> !StashedAVVMAddresses era -> NewEpochState era
type family StashedAVVMAddresses era

-- | AVVM addresses to be removed at the end of the Shelley era. Note that
--   the existence of this field is a hack, related to the transition of
--   UTxO to disk. We remove AVVM addresses from the UTxO on the
--   Shelley/Allegra boundary. However, by this point the UTxO will be
--   moved to disk, and hence doing a scan of the UTxO for AVVM addresses
--   will be expensive. Our solution to this is to do a scan of the UTxO on
--   the Byron/Shelley boundary (since Byron UTxO are still on disk), stash
--   the results here, and then remove them at the Shelley/Allegra
--   boundary.
--   
--   This is very much an awkward implementation hack, and hence we hide it
--   from as many places as possible.
stashedAVVMAddresses :: NewEpochState era -> StashedAVVMAddresses era
getGKeys :: NewEpochState era -> Set (KeyHash 'Genesis (EraCrypto era))

-- | Update new epoch state
updateNES :: EraGov era => NewEpochState era -> BlocksMade (EraCrypto era) -> LedgerState era -> NewEpochState era

-- | Calculate the current circulation
--   
--   This is used in the rewards calculation, and for API endpoints for
--   pool ranking.
circulation :: EpochState era -> Coin -> Coin
decayFactor :: Float
returnRedeemAddrsToReserves :: forall era. EraTxOut era => EpochState era -> EpochState era
updateNonMyopic :: NonMyopic c -> Coin -> Map (KeyHash 'StakePool c) Likelihood -> NonMyopic c

-- | Calculate the change to the deposit pool for a given transaction.
depositPoolChange :: ShelleyEraTxBody era => LedgerState era -> PParams era -> TxBody era -> Coin
emptyRewardUpdate :: RewardUpdate c
pvCanFollow :: ProtVer -> StrictMaybe ProtVer -> Bool
reapRewards :: UMap c -> RewardAccounts c -> UMap c

-- | This function returns the coin balance of a given pot, either the
--   reserves or the treasury, after the instantaneous rewards and pot
--   transfers are accounted for.
availableAfterMIR :: MIRPot -> AccountState -> InstantaneousRewards c -> Coin
data ShelleyGovState era
ShelleyGovState :: !ProposedPPUpdates era -> !ProposedPPUpdates era -> !PParams era -> !PParams era -> ShelleyGovState era
[proposals] :: ShelleyGovState era -> !ProposedPPUpdates era
[futureProposals] :: ShelleyGovState era -> !ProposedPPUpdates era
[sgovPp] :: ShelleyGovState era -> !PParams era
[sgovPrevPp] :: ShelleyGovState era -> !PParams era
nesPdL :: Lens' (NewEpochState era) (PoolDistr (EraCrypto era))
nesEsL :: Lens' (NewEpochState era) (EpochState era)
unifiedL :: Lens' (NewEpochState era) (UMap (EraCrypto era))
nesELL :: Lens' (NewEpochState era) EpochNo
nesBprevL :: Lens' (NewEpochState era) (Map (KeyHash 'StakePool (EraCrypto era)) Natural)
nesBcurL :: Lens' (NewEpochState era) (Map (KeyHash 'StakePool (EraCrypto era)) Natural)
nesRuL :: Lens' (NewEpochState era) (StrictMaybe (PulsingRewUpdate (EraCrypto era)))
nesStashedAVVMAddressesL :: Lens' (NewEpochState era) (StashedAVVMAddresses era)
nesEpochStateL :: Lens' (NewEpochState era) (EpochState era)
esAccountStateL :: Lens' (EpochState era) AccountState
esSnapshotsL :: Lens' (EpochState era) (SnapShots (EraCrypto era))
esLStateL :: Lens' (EpochState era) (LedgerState era)
esNonMyopicL :: Lens' (EpochState era) (NonMyopic (EraCrypto era))
curPParamsEpochStateL :: EraGov era => Lens' (EpochState era) (PParams era)
prevPParamsEpochStateL :: EraGov era => Lens' (EpochState era) (PParams era)
asTreasuryL :: Lens' AccountState Coin
asReservesL :: Lens' AccountState Coin
lsUTxOStateL :: Lens' (LedgerState era) (UTxOState era)
lsCertStateL :: Lens' (LedgerState era) (CertState era)
utxosUtxoL :: Lens' (UTxOState era) (UTxO era)
utxosDepositedL :: Lens' (UTxOState era) Coin
utxosFeesL :: Lens' (UTxOState era) Coin
utxosGovStateL :: Lens' (UTxOState era) (GovState era)
utxosStakeDistrL :: Lens' (UTxOState era) (IncrementalStake (EraCrypto era))
utxosDonationL :: Lens' (UTxOState era) Coin
epochStateGovStateL :: Lens' (EpochState era) (GovState era)
epochStateStakeDistrL :: Lens' (EpochState era) (VMap VB VP (Credential 'Staking (EraCrypto era)) (CompactForm Coin))
epochStateUMapL :: Lens' (EpochState era) (UMap (EraCrypto era))
epochStateRegDrepL :: Lens' (EpochState era) (Map (Credential 'DRepRole (EraCrypto era)) (DRepState (EraCrypto era)))
epochStateIncrStakeDistrL :: Lens' (EpochState era) (Map (Credential 'Staking (EraCrypto era)) (CompactForm Coin))
epochStateDonationL :: Lens' (EpochState era) Coin
newEpochStateGovStateL :: Lens' (NewEpochState era) (GovState era)
epochStateTreasuryL :: Lens' (EpochState era) Coin
certDStateL :: forall era f. Functor f => (DState era -> f (DState era)) -> CertState era -> f (CertState era)
certPStateL :: forall era f. Functor f => (PState era -> f (PState era)) -> CertState era -> f (CertState era)
certVStateL :: forall era f. Functor f => (VState era -> f (VState era)) -> CertState era -> f (CertState era)
dsUnifiedL :: forall era f. Functor f => (UMap (EraCrypto era) -> f (UMap (EraCrypto era))) -> DState era -> f (DState era)
dsGenDelegsL :: forall era f. Functor f => (GenDelegs (EraCrypto era) -> f (GenDelegs (EraCrypto era))) -> DState era -> f (DState era)
dsIRewardsL :: forall era f. Functor f => (InstantaneousRewards (EraCrypto era) -> f (InstantaneousRewards (EraCrypto era))) -> DState era -> f (DState era)
dsFutureGenDelegsL :: forall era f. Functor f => (Map (FutureGenDeleg (EraCrypto era)) (GenDelegPair (EraCrypto era)) -> f (Map (FutureGenDeleg (EraCrypto era)) (GenDelegPair (EraCrypto era)))) -> DState era -> f (DState era)
psStakePoolParamsL :: forall era f. Functor f => (Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)) -> f (Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)))) -> PState era -> f (PState era)
psFutureStakePoolParamsL :: forall era f. Functor f => (Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)) -> f (Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)))) -> PState era -> f (PState era)
psRetiringL :: forall era f. Functor f => (Map (KeyHash 'StakePool (EraCrypto era)) EpochNo -> f (Map (KeyHash 'StakePool (EraCrypto era)) EpochNo)) -> PState era -> f (PState era)
psDepositsL :: forall era f. Functor f => (Map (KeyHash 'StakePool (EraCrypto era)) Coin -> f (Map (KeyHash 'StakePool (EraCrypto era)) Coin)) -> PState era -> f (PState era)
vsDRepsL :: forall era f. Functor f => (Map (Credential 'DRepRole (EraCrypto era)) (DRepState (EraCrypto era)) -> f (Map (Credential 'DRepRole (EraCrypto era)) (DRepState (EraCrypto era)))) -> VState era -> f (VState era)
vsCommitteeStateL :: forall era f. Functor f => (CommitteeState era -> f (CommitteeState era)) -> VState era -> f (VState era)
credMapL :: Lens' (IncrementalStake c) (Map (Credential 'Staking c) (CompactForm Coin))
ssStakeMarkL :: forall c f. Functor f => (SnapShot c -> f (SnapShot c)) -> SnapShots c -> f (SnapShots c)
ssStakeMarkPoolDistrL :: forall c f. Functor f => (PoolDistr c -> f (PoolDistr c)) -> SnapShots c -> f (SnapShots c)
ssStakeSetL :: forall c f. Functor f => (SnapShot c -> f (SnapShot c)) -> SnapShots c -> f (SnapShots c)
ssStakeGoL :: forall c f. Functor f => (SnapShot c -> f (SnapShot c)) -> SnapShots c -> f (SnapShots c)
ssFeeL :: forall c f. Functor f => (Coin -> f Coin) -> SnapShots c -> f (SnapShots c)
ssStakeL :: forall c f. Functor f => (Stake c -> f (Stake c)) -> SnapShot c -> f (SnapShot c)
ssStakeDistrL :: forall c f. Functor f => (VMap VB VP (Credential 'Staking c) (CompactForm Coin) -> f (VMap VB VP (Credential 'Staking c) (CompactForm Coin))) -> SnapShot c -> f (SnapShot c)
ssDelegationsL :: forall c f. Functor f => (VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c) -> f (VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c))) -> SnapShot c -> f (SnapShot c)
ssPoolParamsL :: forall c f. Functor f => (VMap VB VB (KeyHash 'StakePool c) (PoolParams c) -> f (VMap VB VB (KeyHash 'StakePool c) (PoolParams c))) -> SnapShot c -> f (SnapShot c)


-- | Besides capturing all configuration that is necessary to progress to a
--   specific era, this interface also provides fast forward functionality
--   that is used in testing and benchmarking in order to initilize a chain
--   in a particular era without going through the trouble of generating
--   all the history for preceeding eras.
module Cardano.Ledger.Shelley.Transition
class (EraTxOut era, EraGov era, ToJSON (TransitionConfig era), FromJSON (TransitionConfig era), Default (StashedAVVMAddresses era)) => EraTransition era where {
    
    -- | Cumulative configuration that is needed to be able to start in a
    --   current era
    data TransitionConfig era :: Type;
}
mkTransitionConfig :: EraTransition era => TranslationContext era -> TransitionConfig (PreviousEra era) -> TransitionConfig era

-- | In case when a previous era is available, we should always be able to
--   access <a>TransitionConfig</a> for the previous era, from within the
--   current era's <a>TransitionConfig</a>
tcPreviousEraConfigL :: (EraTransition era, EraTransition (PreviousEra era)) => Lens' (TransitionConfig era) (TransitionConfig (PreviousEra era))

-- | Lens for the <a>TranslationContext</a> for the current era from the
--   <a>TransitionConfig</a> Translation context is a different name for
--   the Genesis type for each era, they are one and the same concept.
tcTranslationContextL :: EraTransition era => Lens' (TransitionConfig era) (TranslationContext era)

-- | Lens for the <a>ShelleyGenesis</a> from the <a>TransitionConfig</a>.
--   Default implementation looks in the previous era's config
tcShelleyGenesisL :: EraTransition era => Lens' (TransitionConfig era) (ShelleyGenesis (EraCrypto era))

-- | Lens for the <a>ShelleyGenesis</a> from the <a>TransitionConfig</a>.
--   Default implementation looks in the previous era's config
tcShelleyGenesisL :: (EraTransition era, EraTransition (PreviousEra era), EraCrypto (PreviousEra era) ~ EraCrypto era) => Lens' (TransitionConfig era) (ShelleyGenesis (EraCrypto era))

-- | Get the initial PParams for the current era from the
--   <a>TransitionConfig</a>. Note that this is only useful for testing and
--   fast forward functionality, because this function assumes no on-chain
--   changes to PParams through PParamsUpdate functionality.
--   
--   Default implementation will use the PParams from the Previous era and
--   the current <a>TranslationContext</a> to construct PParams for the
--   current era.
--   
--   <i>Warning</i> - Should only be used in testing and benchmarking
tcInitialPParamsG :: EraTransition era => SimpleGetter (TransitionConfig era) (PParams era)

-- | Get the initial PParams for the current era from the
--   <a>TransitionConfig</a>. Note that this is only useful for testing and
--   fast forward functionality, because this function assumes no on-chain
--   changes to PParams through PParamsUpdate functionality.
--   
--   Default implementation will use the PParams from the Previous era and
--   the current <a>TranslationContext</a> to construct PParams for the
--   current era.
--   
--   <i>Warning</i> - Should only be used in testing and benchmarking
tcInitialPParamsG :: (EraTransition era, EraTransition (PreviousEra era), TranslateEra era PParams, TranslationError era PParams ~ Void) => SimpleGetter (TransitionConfig era) (PParams era)

-- | Constructor for the base Shelley <a>TransitionConfig</a>
mkShelleyTransitionConfig :: ShelleyGenesis c -> TransitionConfig (ShelleyEra c)

-- | Get the initial funds from the <a>TransitionConfig</a>. This value
--   must be non-empty only during testing and benchmarking, it must never
--   contain anything on a real system.
--   
--   <i>Warning</i> - Should only be used in testing and benchmarking. Will
--   result in an error when NetworkId is set to Mainnet
tcInitialFundsL :: (HasCallStack, EraTransition era) => Lens' (TransitionConfig era) (ListMap (Addr (EraCrypto era)) Coin)

-- | Get the initial staking from the <a>TransitionConfig</a>. This value
--   must be non-empty only during testing and benchmarking, it must never
--   contain anything on a real system.
--   
--   <i>Warning</i> - Should only be used in testing and benchmarking. Will
--   result in an error when NetworkId is set to Mainnet
tcInitialStakingL :: (HasCallStack, EraTransition era) => Lens' (TransitionConfig era) (ShelleyGenesisStaking (EraCrypto era))

-- | Helper function for constructing the initial state for any era
--   
--   <i>Warning</i> - Should only be used in testing and benchmarking. Will
--   result in an error when NetworkId is set to Mainnet
createInitialState :: forall era. (EraTransition era, HasCallStack) => TransitionConfig era -> NewEpochState era

-- | Register the initial funds in the <a>NewEpochState</a>.
--   
--   HERE BE DRAGONS! This function is intended to help in testing.
--   
--   In production, the genesis should <i>not</i> contain any initial
--   funds.
--   
--   The given funds are <i>added</i> to the existing UTxO.
--   
--   PRECONDITION: the given funds must not be part of the existing UTxO.
--   &gt; forall (addr, _) in initialFunds. &gt; Map.notElem
--   (initialFundsPseudoTxIn addr) existingUTxO
--   
--   PROPERTY: &gt; genesisUTxO genesis &gt; == <a>genesisUTxO'</a>
--   (sgInitialFunds genesis) &gt; == <a>extractUTxO</a>
--   (registerInitialFunds (sgInitialFunds genesis) &gt;
--   <a>NewEpochState</a>)
--   
--   <i>Warning</i> - Should only be used in testing and benchmarking. Will
--   result in an error when NetworkId is set to Mainnet
registerInitialFunds :: forall era. (EraTransition era, HasCallStack) => TransitionConfig era -> NewEpochState era -> NewEpochState era

-- | Register the initial staking information in the <a>NewEpochState</a>.
--   
--   HERE BE DRAGONS! This function is intended to help in testing.
--   
--   In production, the genesis should <i>not</i> contain any initial
--   staking.
--   
--   Any existing staking information is overridden, but the UTxO is left
--   untouched.
--   
--   <i>Warning</i> - Should only be used in testing and benchmarking. Will
--   result in an error when NetworkId is set to Mainnet
registerInitialStaking :: forall era. (EraTransition era, HasCallStack) => TransitionConfig era -> NewEpochState era -> NewEpochState era
toShelleyTransitionConfigPairs :: (KeyValue a, Crypto c) => TransitionConfig (ShelleyEra c) -> [a]
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Transition.TransitionConfig (Cardano.Ledger.Shelley.Era.ShelleyEra c))
instance Cardano.Ledger.Crypto.Crypto c => GHC.Show.Show (Cardano.Ledger.Shelley.Transition.TransitionConfig (Cardano.Ledger.Shelley.Era.ShelleyEra c))
instance Cardano.Ledger.Crypto.Crypto c => GHC.Classes.Eq (Cardano.Ledger.Shelley.Transition.TransitionConfig (Cardano.Ledger.Shelley.Era.ShelleyEra c))
instance Cardano.Ledger.Crypto.Crypto c => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Transition.TransitionConfig (Cardano.Ledger.Shelley.Era.ShelleyEra c))
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Transition.EraTransition (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.Transition.TransitionConfig (Cardano.Ledger.Shelley.Era.ShelleyEra c))
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.Transition.TransitionConfig (Cardano.Ledger.Shelley.Era.ShelleyEra c))

module Cardano.Ledger.Shelley.Rules
data ShelleyBBODY era
data ShelleyBbodyState era
BbodyState :: State (EraRule "LEDGERS" era) -> BlocksMade (EraCrypto era) -> ShelleyBbodyState era
data BbodyEnv era
BbodyEnv :: PParams era -> AccountState -> BbodyEnv era
[bbodyPp] :: BbodyEnv era -> PParams era
[bbodyAccount] :: BbodyEnv era -> AccountState
data ShelleyBbodyPredFailure era
WrongBlockBodySizeBBODY :: !Int -> !Int -> ShelleyBbodyPredFailure era
InvalidBodyHashBBODY :: !Hash (EraCrypto era) EraIndependentBlockBody -> !Hash (EraCrypto era) EraIndependentBlockBody -> ShelleyBbodyPredFailure era
LedgersFailure :: PredicateFailure (EraRule "LEDGERS" era) -> ShelleyBbodyPredFailure era
newtype ShelleyBbodyEvent era
LedgersEvent :: Event (EraRule "LEDGERS" era) -> ShelleyBbodyEvent era
type family PredicateFailure a
type family State a
data ShelleyDELEG era
data DelegEnv era
DelegEnv :: SlotNo -> Ptr -> AccountState -> PParams era -> DelegEnv era
[slotNo] :: DelegEnv era -> SlotNo
[ptr_] :: DelegEnv era -> Ptr
[acnt_] :: DelegEnv era -> AccountState
[ppDE] :: DelegEnv era -> PParams era
type family PredicateFailure a
data ShelleyDelegPredFailure era
StakeKeyAlreadyRegisteredDELEG :: !Credential 'Staking (EraCrypto era) -> ShelleyDelegPredFailure era

-- | Indicates that the stake key is somehow already in the rewards map.
--   This error is now redundant with StakeKeyAlreadyRegisteredDELEG. We
--   should remove it and replace its one use with
--   StakeKeyAlreadyRegisteredDELEG.
StakeKeyInRewardsDELEG :: !Credential 'Staking (EraCrypto era) -> ShelleyDelegPredFailure era
StakeKeyNotRegisteredDELEG :: !Credential 'Staking (EraCrypto era) -> ShelleyDelegPredFailure era
StakeKeyNonZeroAccountBalanceDELEG :: !Maybe Coin -> ShelleyDelegPredFailure era
StakeDelegationImpossibleDELEG :: !Credential 'Staking (EraCrypto era) -> ShelleyDelegPredFailure era
WrongCertificateTypeDELEG :: ShelleyDelegPredFailure era
GenesisKeyNotInMappingDELEG :: !KeyHash 'Genesis (EraCrypto era) -> ShelleyDelegPredFailure era
DuplicateGenesisDelegateDELEG :: !KeyHash 'GenesisDelegate (EraCrypto era) -> ShelleyDelegPredFailure era
InsufficientForInstantaneousRewardsDELEG :: !MIRPot -> !Coin -> !Coin -> ShelleyDelegPredFailure era
MIRCertificateTooLateinEpochDELEG :: !SlotNo -> !SlotNo -> ShelleyDelegPredFailure era
DuplicateGenesisVRFDELEG :: !Hash (EraCrypto era) (VerKeyVRF (EraCrypto era)) -> ShelleyDelegPredFailure era
MIRTransferNotCurrentlyAllowed :: ShelleyDelegPredFailure era
MIRNegativesNotCurrentlyAllowed :: ShelleyDelegPredFailure era
InsufficientForTransferDELEG :: !MIRPot -> !Coin -> !Coin -> ShelleyDelegPredFailure era
MIRProducesNegativeUpdate :: ShelleyDelegPredFailure era
MIRNegativeTransfer :: !MIRPot -> !Coin -> ShelleyDelegPredFailure era
data ShelleyDELEGS era
data DelegsEnv era
DelegsEnv :: !SlotNo -> !TxIx -> !PParams era -> !Tx era -> !AccountState -> DelegsEnv era
[delegsSlotNo] :: DelegsEnv era -> !SlotNo
[delegsIx] :: DelegsEnv era -> !TxIx
[delegspp] :: DelegsEnv era -> !PParams era
[delegsTx] :: DelegsEnv era -> !Tx era
[delegsAccount] :: DelegsEnv era -> !AccountState
data ShelleyDelegsPredFailure era

-- | Target pool which is not registered
DelegateeNotRegisteredDELEG :: !KeyHash 'StakePool (EraCrypto era) -> ShelleyDelegsPredFailure era

-- | Withdrawals that are missing or do not withdrawal the entire amount
WithdrawalsNotInRewardsDELEGS :: !Map (RewardAcnt (EraCrypto era)) Coin -> ShelleyDelegsPredFailure era

-- | Subtransition Failures
DelplFailure :: !PredicateFailure (EraRule "DELPL" era) -> ShelleyDelegsPredFailure era
newtype ShelleyDelegsEvent era
DelplEvent :: Event (EraRule "DELPL" era) -> ShelleyDelegsEvent era
type family PredicateFailure a
validateZeroRewards :: forall era. DState era -> Withdrawals (EraCrypto era) -> Network -> Test (Map (RewardAcnt (EraCrypto era)) Coin)
validateStakePoolDelegateeRegistered :: PState era -> KeyHash 'StakePool (EraCrypto era) -> Test (KeyHash 'StakePool (EraCrypto era))
drainWithdrawals :: DState era -> Withdrawals (EraCrypto era) -> DState era
data ShelleyDELPL era
data DelplEnv era
DelplEnv :: SlotNo -> Ptr -> PParams era -> AccountState -> DelplEnv era
[delplSlotNo] :: DelplEnv era -> SlotNo
[delPlPtr] :: DelplEnv era -> Ptr
[delPlPp] :: DelplEnv era -> PParams era
[delPlAcnt] :: DelplEnv era -> AccountState
data ShelleyDelplPredFailure era
PoolFailure :: PredicateFailure (EraRule "POOL" era) -> ShelleyDelplPredFailure era
DelegFailure :: PredicateFailure (EraRule "DELEG" era) -> ShelleyDelplPredFailure era
data ShelleyDelplEvent era
type family PredicateFailure a
data ShelleyEPOCH era
data ShelleyEpochPredFailure era
PoolReapFailure :: PredicateFailure (EraRule "POOLREAP" era) -> ShelleyEpochPredFailure era
SnapFailure :: PredicateFailure (EraRule "SNAP" era) -> ShelleyEpochPredFailure era
UpecFailure :: UpecPredFailure era -> ShelleyEpochPredFailure era
data ShelleyEpochEvent era
PoolReapEvent :: Event (EraRule "POOLREAP" era) -> ShelleyEpochEvent era
SnapEvent :: Event (EraRule "SNAP" era) -> ShelleyEpochEvent era
UpecEvent :: Event (EraRule "UPEC" era) -> ShelleyEpochEvent era
type family PredicateFailure a
type UpecPredFailure era = UpecPredFailurePV (ProtVerLow era) era
data ShelleyLEDGER era
data LedgerEnv era
LedgerEnv :: !SlotNo -> !TxIx -> !PParams era -> !AccountState -> LedgerEnv era
[ledgerSlotNo] :: LedgerEnv era -> !SlotNo
[ledgerIx] :: LedgerEnv era -> !TxIx
[ledgerPp] :: LedgerEnv era -> !PParams era
[ledgerAccount] :: LedgerEnv era -> !AccountState
data ShelleyLedgerPredFailure era
UtxowFailure :: PredicateFailure (EraRule "UTXOW" era) -> ShelleyLedgerPredFailure era
DelegsFailure :: PredicateFailure (EraRule "DELEGS" era) -> ShelleyLedgerPredFailure era
data ShelleyLedgerEvent era
UtxowEvent :: Event (EraRule "UTXOW" era) -> ShelleyLedgerEvent era
DelegsEvent :: Event (EraRule "DELEGS" era) -> ShelleyLedgerEvent era
type family Event a
type family PredicateFailure a
epochFromSlot :: SlotNo -> Reader Globals EpochNo
depositEqualsObligation :: (EraTx era, ShelleyEraTxBody era, Environment t ~ LedgerEnv era, Signal t ~ Tx era, State t ~ LedgerState era) => AssertionViolation t -> String
shelleyLedgerAssertions :: (EraGov era, State (rule era) ~ LedgerState era) => [Assertion (rule era)]
data ShelleyLEDGERS era
data ShelleyLedgersEnv era
LedgersEnv :: SlotNo -> PParams era -> AccountState -> ShelleyLedgersEnv era
[ledgersSlotNo] :: ShelleyLedgersEnv era -> SlotNo
[ledgersPp] :: ShelleyLedgersEnv era -> PParams era
[ledgersAccount] :: ShelleyLedgersEnv era -> AccountState
newtype ShelleyLedgersPredFailure era
LedgerFailure :: PredicateFailure (EraRule "LEDGER" era) -> ShelleyLedgersPredFailure era
newtype ShelleyLedgersEvent era
LedgerEvent :: Event (EraRule "LEDGER" era) -> ShelleyLedgersEvent era
type family PredicateFailure a
data ShelleyMIR era
type family PredicateFailure a
data ShelleyMirPredFailure era
data ShelleyMirEvent era
MirTransfer :: InstantaneousRewards (EraCrypto era) -> ShelleyMirEvent era

-- | We were not able to perform an MIR transfer due to insufficient funds.
--   This event gives the rewards we wanted to pay, plus the available
--   reserves and treasury.
NoMirTransfer :: InstantaneousRewards (EraCrypto era) -> Coin -> Coin -> ShelleyMirEvent era
emptyInstantaneousRewards :: InstantaneousRewards c
data ShelleyNEWEPOCH era
data ShelleyNewEpochPredFailure era
EpochFailure :: PredicateFailure (EraRule "EPOCH" era) -> ShelleyNewEpochPredFailure era
CorruptRewardUpdate :: !RewardUpdate (EraCrypto era) -> ShelleyNewEpochPredFailure era
MirFailure :: PredicateFailure (EraRule "MIR" era) -> ShelleyNewEpochPredFailure era
data ShelleyNewEpochEvent era
DeltaRewardEvent :: Event (EraRule "RUPD" era) -> ShelleyNewEpochEvent era
RestrainedRewards :: EpochNo -> Map (Credential 'Staking (EraCrypto era)) (Set (Reward (EraCrypto era))) -> Set (Credential 'Staking (EraCrypto era)) -> ShelleyNewEpochEvent era
TotalRewardEvent :: EpochNo -> Map (Credential 'Staking (EraCrypto era)) (Set (Reward (EraCrypto era))) -> ShelleyNewEpochEvent era
EpochEvent :: Event (EraRule "EPOCH" era) -> ShelleyNewEpochEvent era
MirEvent :: Event (EraRule "MIR" era) -> ShelleyNewEpochEvent era
TotalAdaPotsEvent :: AdaPots -> ShelleyNewEpochEvent era
type family PredicateFailure a
updateRewards :: EraGov era => EpochState era -> EpochNo -> RewardUpdate (EraCrypto era) -> Rule (ShelleyNEWEPOCH era) 'Transition (EpochState era)
calculatePoolDistr :: SnapShot c -> PoolDistr c
calculatePoolDistr' :: (KeyHash 'StakePool c -> Bool) -> SnapShot c -> PoolDistr c
data ShelleyNEWPP era
data ShelleyNewppState era
NewppState :: PParams era -> ShelleyGovState era -> ShelleyNewppState era
data NewppEnv era
NewppEnv :: DState era -> PState era -> UTxOState era -> NewppEnv era
data ShelleyNewppPredFailure era
UnexpectedDepositPot :: !Coin -> !Coin -> ShelleyNewppPredFailure era
type family PredicateFailure a
data ShelleyPOOL era
data PoolEvent era
RegisterPool :: KeyHash 'StakePool (EraCrypto era) -> PoolEvent era
ReregisterPool :: KeyHash 'StakePool (EraCrypto era) -> PoolEvent era
data PoolEnv era
PoolEnv :: !SlotNo -> !PParams era -> PoolEnv era
type family PredicateFailure a
data ShelleyPoolPredFailure era
StakePoolNotRegisteredOnKeyPOOL :: !KeyHash 'StakePool (EraCrypto era) -> ShelleyPoolPredFailure era
StakePoolRetirementWrongEpochPOOL :: !EpochNo -> !EpochNo -> !EpochNo -> ShelleyPoolPredFailure era
StakePoolCostTooLowPOOL :: !Coin -> !Coin -> ShelleyPoolPredFailure era
WrongNetworkPOOL :: !Network -> !Network -> !KeyHash 'StakePool (EraCrypto era) -> ShelleyPoolPredFailure era
PoolMedataHashTooBig :: !KeyHash 'StakePool (EraCrypto era) -> !Int -> ShelleyPoolPredFailure era
poolCertTransition :: forall (ledger :: Type -> Type) era c. (EraCrypto era ~ c, EraPParams era, State (ledger era) ~ PState era, STS (ledger era), Event (ledger era) ~ PoolEvent era, BaseM (ledger era) ~ ShelleyBase, PredicateFailure (ledger era) ~ ShelleyPoolPredFailure era) => PoolEnv era -> PState era -> PoolCert c -> TransitionRule (ledger era)
data ShelleyPOOLREAP era
data ShelleyPoolreapEvent era
RetiredPools :: Map (Credential 'Staking (EraCrypto era)) (Map (KeyHash 'StakePool (EraCrypto era)) Coin) -> Map (Credential 'Staking (EraCrypto era)) (Map (KeyHash 'StakePool (EraCrypto era)) Coin) -> EpochNo -> ShelleyPoolreapEvent era
[refundPools] :: ShelleyPoolreapEvent era -> Map (Credential 'Staking (EraCrypto era)) (Map (KeyHash 'StakePool (EraCrypto era)) Coin)
[unclaimedPools] :: ShelleyPoolreapEvent era -> Map (Credential 'Staking (EraCrypto era)) (Map (KeyHash 'StakePool (EraCrypto era)) Coin)
[epochNo] :: ShelleyPoolreapEvent era -> EpochNo
data ShelleyPoolreapState era
PoolreapState :: UTxOState era -> AccountState -> DState era -> PState era -> ShelleyPoolreapState era
[prUTxOSt] :: ShelleyPoolreapState era -> UTxOState era
[prAcnt] :: ShelleyPoolreapState era -> AccountState
[prDState] :: ShelleyPoolreapState era -> DState era
[prPState] :: ShelleyPoolreapState era -> PState era
newtype ShelleyPoolreapEnv era
ShelleyPoolreapEnv :: VState era -> ShelleyPoolreapEnv era

-- | This enviroment field is only needed for assertions.
[speVState] :: ShelleyPoolreapEnv era -> VState era
type family PredicateFailure a
data ShelleyPoolreapPredFailure era
data ShelleyPPUP era
data PpupEnv era
PPUPEnv :: SlotNo -> PParams era -> GenDelegs (EraCrypto era) -> PpupEnv era
data ShelleyPpupPredFailure era

-- | An update was proposed by a key hash that is not one of the genesis
--   keys. The first set contains the key hashes which were a part of the
--   update. The second set contains the key hashes of the genesis keys.
NonGenesisUpdatePPUP :: !Set (KeyHash 'Genesis (EraCrypto era)) -> !Set (KeyHash 'Genesis (EraCrypto era)) -> ShelleyPpupPredFailure era

-- | An update was proposed for the wrong epoch. The first <a>EpochNo</a>
--   is the current epoch. The second <a>EpochNo</a> is the epoch listed in
--   the update. The last parameter indicates if the update was intended
--   for the current or the next epoch.
PPUpdateWrongEpoch :: !EpochNo -> !EpochNo -> !VotingPeriod -> ShelleyPpupPredFailure era

-- | An update was proposed which contains an invalid protocol version. New
--   protocol versions must either increase the major number by exactly one
--   and set the minor version to zero, or keep the major version the same
--   and increase the minor version by exactly one.
PVCannotFollowPPUP :: !ProtVer -> ShelleyPpupPredFailure era
data ShelleyGovState era
ShelleyGovState :: !ProposedPPUpdates era -> !ProposedPPUpdates era -> !PParams era -> !PParams era -> ShelleyGovState era
[proposals] :: ShelleyGovState era -> !ProposedPPUpdates era
[futureProposals] :: ShelleyGovState era -> !ProposedPPUpdates era
[sgovPp] :: ShelleyGovState era -> !PParams era
[sgovPrevPp] :: ShelleyGovState era -> !PParams era
newtype PpupEvent era
NewEpoch :: EpochNo -> PpupEvent era
type family PredicateFailure a
data VotingPeriod
VoteForThisEpoch :: VotingPeriod
VoteForNextEpoch :: VotingPeriod
type PPUPPredFailure era = PPUPPredFailurePV (ProtVerLow era) era
data ShelleyRUPD era
data RupdEnv era
RupdEnv :: BlocksMade (EraCrypto era) -> EpochState era -> RupdEnv era
type family PredicateFailure a
data ShelleyRupdPredFailure era
epochInfoRange :: Monad m => EpochInfo m -> EpochNo -> m (SlotNo, SlotNo)

-- | The state used in the STS rules
data PulsingRewUpdate c
Pulsing :: !RewardSnapShot c -> !Pulser c -> PulsingRewUpdate c
Complete :: !RewardUpdate c -> PulsingRewUpdate c
startStep :: forall era. EraGov era => EpochSize -> BlocksMade (EraCrypto era) -> EpochState era -> Coin -> ActiveSlotCoeff -> Word64 -> PulsingRewUpdate (EraCrypto era)

-- | Run the pulser for a bit. If is has nothing left to do, complete it.
pulseStep :: PulsingRewUpdate c -> ShelleyBase (PulsingRewUpdate c, RewardEvent c)
completeStep :: PulsingRewUpdate c -> ShelleyBase (PulsingRewUpdate c, RewardEvent c)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | Identity functor and monad. (a non-strict monad)
newtype () => Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a
data RupdEvent c
RupdEvent :: !EpochNo -> !Map (Credential 'Staking c) (Set (Reward c)) -> RupdEvent c
data ShelleySNAP era
type family PredicateFailure a
data ShelleySnapPredFailure era
newtype SnapEvent era
StakeDistEvent :: Map (Credential 'Staking (EraCrypto era)) (Coin, KeyHash 'StakePool (EraCrypto era)) -> SnapEvent era
data SnapEnv era
SnapEnv :: !LedgerState era -> !PParams era -> SnapEnv era
data ShelleyTICK era
type family State a
data ShelleyTickPredFailure era
NewEpochFailure :: PredicateFailure (EraRule "NEWEPOCH" era) -> ShelleyTickPredFailure era
RupdFailure :: PredicateFailure (EraRule "RUPD" era) -> ShelleyTickPredFailure era
data ShelleyTickEvent era
TickNewEpochEvent :: Event (EraRule "NEWEPOCH" era) -> ShelleyTickEvent era
TickRupdEvent :: Event (EraRule "RUPD" era) -> ShelleyTickEvent era
type family PredicateFailure a
adoptGenesisDelegs :: EpochState era -> SlotNo -> EpochState era
data ShelleyTICKF era
data ShelleyTickfPredFailure era

-- | This is a limited version of <a>bheadTransition</a> which is suitable
--   for the future ledger view.
validatingTickTransition :: forall tick era. (Embed (EraRule "NEWEPOCH" era) (tick era), STS (tick era), State (tick era) ~ NewEpochState era, BaseM (tick era) ~ ShelleyBase, Environment (EraRule "NEWEPOCH" era) ~ (), State (EraRule "NEWEPOCH" era) ~ NewEpochState era, Signal (EraRule "NEWEPOCH" era) ~ EpochNo) => NewEpochState era -> SlotNo -> TransitionRule (tick era)

-- | This is a limited version of <a>validatingTickTransition</a> which is
--   only suitable for the future ledger view.
validatingTickTransitionFORECAST :: forall tick era. (State (tick era) ~ NewEpochState era, BaseM (tick era) ~ ShelleyBase, State (EraRule "UPEC" era) ~ UpecState era, Signal (EraRule "UPEC" era) ~ (), Environment (EraRule "UPEC" era) ~ EpochState era, Embed (EraRule "UPEC" era) (tick era), STS (tick era), GovState era ~ ShelleyGovState era, EraGov era) => NewEpochState era -> SlotNo -> TransitionRule (tick era)
data ShelleyUPEC era
data UpecState era
UpecState :: !PParams era -> !ShelleyGovState era -> UpecState era

-- | Current protocol parameters.
[currentPp] :: UpecState era -> !PParams era

-- | State of the protocol update transition system.
[ppupState] :: UpecState era -> !ShelleyGovState era
newtype ShelleyUpecPredFailure era
NewPpFailure :: PredicateFailure (ShelleyNEWPP era) -> ShelleyUpecPredFailure era

-- | If at least <tt>n</tt> nodes voted to change <b>the same</b> protocol
--   parameters to <b>the same</b> values, return the given protocol
--   parameters updated to these values. Here <tt>n</tt> is the quorum
--   needed.
votedValue :: forall era. EraPParams era => ProposedPPUpdates era -> PParams era -> Int -> Maybe (PParams era)
data ShelleyUTXO era
data UtxoEnv era
UtxoEnv :: SlotNo -> PParams era -> CertState era -> GenDelegs (EraCrypto era) -> UtxoEnv era
[ueSlot] :: UtxoEnv era -> SlotNo
[uePParams] :: UtxoEnv era -> PParams era
[ueCertState] :: UtxoEnv era -> CertState era
[ueGenDelegs] :: UtxoEnv era -> GenDelegs (EraCrypto era)
data ShelleyUtxoPredFailure era
BadInputsUTxO :: !Set (TxIn (EraCrypto era)) -> ShelleyUtxoPredFailure era
ExpiredUTxO :: !SlotNo -> !SlotNo -> ShelleyUtxoPredFailure era
MaxTxSizeUTxO :: !Integer -> !Integer -> ShelleyUtxoPredFailure era
InputSetEmptyUTxO :: ShelleyUtxoPredFailure era
FeeTooSmallUTxO :: !Coin -> !Coin -> ShelleyUtxoPredFailure era
ValueNotConservedUTxO :: !Value era -> !Value era -> ShelleyUtxoPredFailure era
WrongNetwork :: !Network -> !Set (Addr (EraCrypto era)) -> ShelleyUtxoPredFailure era
WrongNetworkWithdrawal :: !Network -> !Set (RewardAcnt (EraCrypto era)) -> ShelleyUtxoPredFailure era
OutputTooSmallUTxO :: ![TxOut era] -> ShelleyUtxoPredFailure era
UpdateFailure :: PPUPPredFailure era -> ShelleyUtxoPredFailure era
OutputBootAddrAttrsTooBig :: ![TxOut era] -> ShelleyUtxoPredFailure era
data UtxoEvent era
TotalDeposits :: SafeHash (EraCrypto era) EraIndependentTxBody -> Coin -> UtxoEvent era
UpdateEvent :: Event (EraRule "PPUP" era) -> UtxoEvent era
type family PredicateFailure a
updateUTxOState :: EraTxBody era => PParams era -> UTxOState era -> TxBody era -> Coin -> GovState era -> UTxOState era

-- | Ensure that there is at least one input in the <a>TxBody</a>
--   
--   <pre>
--   txins txb ≠ ∅
--   </pre>
validateInputSetEmptyUTxO :: EraTxBody era => TxBody era -> Test (ShelleyUtxoPredFailure era)

-- | Ensure that the fee is at least the amount specified by the
--   <tt>minfee</tt>
--   
--   <pre>
--   minfee pp tx ≤ txfee txb
--   </pre>
validateFeeTooSmallUTxO :: EraTx era => PParams era -> Tx era -> Test (ShelleyUtxoPredFailure era)

-- | Ensure all transaction inputs are present in <a>UTxO</a>
--   
--   <pre>
--   inputs ⊆ dom utxo
--   </pre>
validateBadInputsUTxO :: UTxO era -> Set (TxIn (EraCrypto era)) -> Test (ShelleyUtxoPredFailure era)

-- | Make sure all addresses match the supplied NetworkId
--   
--   <pre>
--   ∀(_ → (a, _)) ∈ txouts txb, netId a = NetworkId
--   </pre>
validateWrongNetwork :: (EraTxOut era, Foldable f) => Network -> f (TxOut era) -> Test (ShelleyUtxoPredFailure era)

-- | Make sure all addresses match the supplied NetworkId
--   
--   <pre>
--   ∀(a → ) ∈ txwdrls txb, netId a = NetworkId
--   </pre>
validateWrongNetworkWithdrawal :: ShelleyEraTxBody era => Network -> TxBody era -> Test (ShelleyUtxoPredFailure era)

-- | Bootstrap (i.e. Byron) addresses have variable sized attributes in
--   them. It is important to limit their overall size.
--   
--   <pre>
--   ∀ ( _ ↦ (a,_)) ∈ txoutstxb,  a ∈ Addrbootstrap → bootstrapAttrsSize a ≤ 64
--   </pre>
validateOutputBootAddrAttrsTooBig :: (EraTxOut era, Foldable f) => f (TxOut era) -> Test (ShelleyUtxoPredFailure era)

-- | Ensure that the size of the transaction does not exceed the
--   <tt>maxTxSize</tt> protocol parameter
--   
--   <pre>
--   txsize tx ≤ maxTxSize pp
--   </pre>
validateMaxTxSizeUTxO :: EraTx era => PParams era -> Tx era -> Test (ShelleyUtxoPredFailure era)

-- | Ensure that value consumed and produced matches up exactly
--   
--   <pre>
--   consumed pp utxo txb = produced pp poolParams txb
--   </pre>
validateValueNotConservedUTxO :: (ShelleyEraTxBody era, EraUTxO era) => PParams era -> UTxO era -> CertState era -> TxBody era -> Test (ShelleyUtxoPredFailure era)
utxoEnvSlotL :: Lens' (UtxoEnv era) SlotNo
utxoEnvPParamsL :: Lens' (UtxoEnv era) (PParams era)
utxoEnvCertStateL :: Lens' (UtxoEnv era) (CertState era)
utxoEnvGenDelegsL :: Lens' (UtxoEnv era) (GenDelegs (EraCrypto era))
data ShelleyUTXOW era
data ShelleyUtxowPredFailure era
InvalidWitnessesUTXOW :: ![VKey 'Witness (EraCrypto era)] -> ShelleyUtxowPredFailure era
MissingVKeyWitnessesUTXOW :: !Set (KeyHash 'Witness (EraCrypto era)) -> ShelleyUtxowPredFailure era
MissingScriptWitnessesUTXOW :: !Set (ScriptHash (EraCrypto era)) -> ShelleyUtxowPredFailure era
ScriptWitnessNotValidatingUTXOW :: !Set (ScriptHash (EraCrypto era)) -> ShelleyUtxowPredFailure era
UtxoFailure :: PredicateFailure (EraRule "UTXO" era) -> ShelleyUtxowPredFailure era
MIRInsufficientGenesisSigsUTXOW :: Set (KeyHash 'Witness (EraCrypto era)) -> ShelleyUtxowPredFailure era
MissingTxBodyMetadataHash :: !AuxiliaryDataHash (EraCrypto era) -> ShelleyUtxowPredFailure era
MissingTxMetadata :: !AuxiliaryDataHash (EraCrypto era) -> ShelleyUtxowPredFailure era
ConflictingMetadataHash :: !AuxiliaryDataHash (EraCrypto era) -> !AuxiliaryDataHash (EraCrypto era) -> ShelleyUtxowPredFailure era
InvalidMetadata :: ShelleyUtxowPredFailure era
ExtraneousScriptWitnessesUTXOW :: !Set (ScriptHash (EraCrypto era)) -> ShelleyUtxowPredFailure era
newtype ShelleyUtxowEvent era
UtxoEvent :: Event (EraRule "UTXO" era) -> ShelleyUtxowEvent era
type family PredicateFailure a

-- | A generic Utxow witnessing function designed to be used across many
--   Eras. Note the <tt>embed</tt> argument lifts from the simple Shelley
--   (ShelleyUtxowPredFailure) to the PredicateFailure (type family) of the
--   context of where it is called.
transitionRulesUTXOW :: forall era utxow. (EraUTxO era, ShelleyEraTxBody era, ProtVerAtMost era 8, ScriptsNeeded era ~ ShelleyScriptsNeeded era, BaseM (utxow era) ~ ShelleyBase, Embed (EraRule "UTXO" era) (utxow era), Environment (EraRule "UTXO" era) ~ UtxoEnv era, State (EraRule "UTXO" era) ~ UTxOState era, Signal (EraRule "UTXO" era) ~ Tx era, Environment (utxow era) ~ UtxoEnv era, State (utxow era) ~ UTxOState era, Signal (utxow era) ~ Tx era, PredicateFailure (utxow era) ~ ShelleyUtxowPredFailure era, STS (utxow era), DSignable (EraCrypto era) (Hash (EraCrypto era) EraIndependentTxBody)) => TransitionRule (utxow era)
shelleyWitsVKeyNeeded :: forall era. (EraTx era, ShelleyEraTxBody era, ProtVerAtMost era 8) => UTxO era -> TxBody era -> GenDelegs (EraCrypto era) -> Set (KeyHash 'Witness (EraCrypto era))

-- | Collect the set of hashes of keys that needs to sign a given
--   transaction. This set consists of the txin owners, certificate
--   authors, and withdrawal reward accounts.
witsVKeyNeededGov :: forall era. (ShelleyEraTxBody era, ProtVerAtMost era 8) => TxBody era -> GenDelegs (EraCrypto era) -> Set (KeyHash 'Witness (EraCrypto era))
witsVKeyNeededNoGov :: forall era. EraTx era => UTxO era -> TxBody era -> Set (KeyHash 'Witness (EraCrypto era))
validateFailedNativeScripts :: EraTx era => ScriptsProvided era -> Tx era -> Test (ShelleyUtxowPredFailure era)
validateMissingScripts :: EraPParams era => PParams era -> ShelleyScriptsNeeded era -> ScriptsProvided era -> Test (ShelleyUtxowPredFailure era)

-- | Given a ledger state, determine if the UTxO witnesses in a given
--   transaction are correct.
validateVerifiedWits :: (EraTx era, DSignable (EraCrypto era) (Hash (EraCrypto era) EraIndependentTxBody)) => Tx era -> Test (ShelleyUtxowPredFailure era)

-- | check metadata hash ((adh = ◇) ∧ (ad= ◇)) ∨ (adh = hashAD ad)
validateMetadata :: EraTx era => PParams era -> Tx era -> Test (ShelleyUtxowPredFailure era)

-- | check genesis keys signatures for instantaneous rewards certificates
--   
--   genSig := { hashKey gkey | gkey ∈ dom(genDelegs)} ∩ witsKeyHashes { c
--   ∈ txcerts txb ∩ TxCert_mir} ≠ ∅ ⇒ |genSig| ≥ Quorum
validateMIRInsufficientGenesisSigs :: (EraTx era, ShelleyEraTxBody era, ProtVerAtMost era 8) => GenDelegs (EraCrypto era) -> Word64 -> Set (KeyHash 'Witness (EraCrypto era)) -> Tx era -> Test (ShelleyUtxowPredFailure era)
validateNeededWitnesses :: Set (KeyHash 'Witness (EraCrypto era)) -> Set (KeyHash 'Witness (EraCrypto era)) -> Test (ShelleyUtxowPredFailure era)

-- | Calculate the set of hash keys of the required witnesses for update
--   proposals.

-- | <i>Deprecated: This is will become an internal function in the future.
--   Submit an issue if you still need it. </i>
propWits :: Maybe (Update era) -> GenDelegs (EraCrypto era) -> Set (KeyHash 'Witness (EraCrypto era))

module Cardano.Ledger.Shelley.API.Wallet

-- | Get the full UTxO.
getUTxO :: NewEpochState era -> UTxO era
getUTxOSubset :: NewEpochState era -> Set (TxIn (EraCrypto era)) -> UTxO era

-- | Get the UTxO filtered by address.
getFilteredUTxO :: EraTxOut era => NewEpochState era -> Set (Addr (EraCrypto era)) -> UTxO era

-- | Get the <i>current</i> registered stake pools.
getPools :: NewEpochState era -> Set (KeyHash 'StakePool (EraCrypto era))

-- | Get the <i>current</i> registered stake pool parameters for a given
--   set of stake pools. The result map will contain entries for all the
--   given stake pools that are currently registered.
getPoolParameters :: NewEpochState era -> Set (KeyHash 'StakePool (EraCrypto era)) -> Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era))

-- | Calculate the current total stake.
getTotalStake :: Globals -> NewEpochState era -> Coin

-- | Get pool sizes, but in terms of total stake
--   
--   The stake distribution uses active stake (so that the leader schedule
--   is not affected by undelegated stake), but the wallet wants to display
--   pool saturation for rewards purposes. For that, it needs the fraction
--   of total stake.
--   
--   This is not based on any snapshot, but uses the current ledger state.
poolsByTotalStakeFraction :: forall era. EraGov era => Globals -> NewEpochState era -> PoolDistr (EraCrypto era)

-- | Information about a stake pool
data RewardInfoPool
RewardInfoPool :: Coin -> Coin -> Coin -> Coin -> UnitInterval -> Double -> RewardInfoPool

-- | Absolute stake delegated to this pool
[stake] :: RewardInfoPool -> Coin

-- | Pledge of pool owner(s)
[ownerPledge] :: RewardInfoPool -> Coin

-- | Absolute stake delegated by pool owner(s)
[ownerStake] :: RewardInfoPool -> Coin

-- | Pool cost
[cost] :: RewardInfoPool -> Coin

-- | Pool margin
[margin] :: RewardInfoPool -> UnitInterval

-- | Number of blocks produced divided by expected number of blocks. Can be
--   larger than <tt>1.0</tt> for pool that gets lucky. (If some pools get
--   unlucky, some pools must get lucky.)
[performanceEstimate] :: RewardInfoPool -> Double

-- | Global information that influences stake pool rewards
data RewardParams
RewardParams :: Natural -> NonNegativeInterval -> Coin -> Coin -> RewardParams

-- | Desired number of stake pools
[nOpt] :: RewardParams -> Natural

-- | Influence of the pool owner's pledge on rewards
[a0] :: RewardParams -> NonNegativeInterval

-- | Total rewards available for the given epoch
[rPot] :: RewardParams -> Coin

-- | Maximum lovelace supply minus treasury
[totalStake] :: RewardParams -> Coin

-- | Retrieve the information necessary to calculate stake pool member
--   rewards from the <i>current</i> stake distribution.
--   
--   This information includes the current stake distribution aggregated by
--   stake pools and pool owners, the <tt>current</tt> pool costs and
--   margins, and performance estimates. Also included are global
--   information such as the total stake or protocol parameters.
getRewardInfoPools :: EraGov era => Globals -> NewEpochState era -> (RewardParams, Map (KeyHash 'StakePool (EraCrypto era)) RewardInfoPool)

-- | Calculate stake pool rewards from the snapshot labeled <tt>go</tt>.
--   Also includes information on how the rewards were calculated
--   (<a>RewardProvenance</a>).
--   
--   For a calculation of rewards based on the current stake distribution,
--   see <a>getRewardInfoPools</a>.
--   
--   TODO: Deprecate <a>getRewardProvenance</a>, because wallets are more
--   likely to use <a>getRewardInfoPools</a> for up-to-date information on
--   stake pool rewards.
getRewardProvenance :: forall era. EraGov era => Globals -> NewEpochState era -> (RewardUpdate (EraCrypto era), RewardProvenance (EraCrypto era))

-- | Calculate the Non-Myopic Pool Member Rewards for a set of credentials.
--   For each given credential, this function returns a map from each stake
--   pool (identified by the key hash of the pool operator) to the
--   non-myopic pool member reward for that stake pool.
--   
--   This is not based on any snapshot, but uses the current ledger state.
getNonMyopicMemberRewards :: EraGov era => Globals -> NewEpochState era -> Set (Either Coin (Credential 'Staking (EraCrypto era))) -> Map (Either Coin (Credential 'Staking (EraCrypto era))) (Map (KeyHash 'StakePool (EraCrypto era)) Coin)
addKeyWitnesses :: EraTx era => Tx era -> Set (WitVKey 'Witness (EraCrypto era)) -> Tx era

-- | The minimum fee calculation. Used for the default implentation of
--   <a>evaluateTransactionFee</a>.

-- | <i>Deprecated: In favor of <a>getMinFeeTx</a></i>
evaluateMinFee :: EraTx era => PParams era -> Tx era -> Coin

-- | Evaluate the fee for a given transaction.
evaluateTransactionFee :: forall era. EraTx era => PParams era -> Tx era -> Word -> Coin

-- | Evaluate the difference between the value currently being consumed by
--   a transaction and the number of lovelace being produced. This value
--   will be zero for a valid transaction.

-- | <i>Deprecated: In favor of new API function
--   <a>evalBalanceTxBody</a></i>
evaluateTransactionBalance :: EraUTxO era => PParams era -> CertState era -> UTxO era -> TxBody era -> Value era

-- | Evaluate the minimum lovelace that a given transaction output must
--   contain.

-- | <i>Deprecated: In favor of <a>getMinCoinTxOut</a></i>
evaluateMinLovelaceOutput :: EraTxOut era => PParams era -> TxOut era -> Coin

-- | <i>Deprecated: In favor of <a>addKeyWitnesses</a></i>
addShelleyKeyWitnesses :: (EraTx era, Tx era ~ ShelleyTx era) => ShelleyTx era -> Set (WitVKey 'Witness (EraCrypto era)) -> ShelleyTx era
data AdaPots
AdaPots :: Coin -> Coin -> Coin -> Coin -> Coin -> Coin -> Coin -> Coin -> AdaPots
[treasuryAdaPot] :: AdaPots -> Coin
[reservesAdaPot] :: AdaPots -> Coin
[rewardsAdaPot] :: AdaPots -> Coin
[utxoAdaPot] :: AdaPots -> Coin
[keyDepositAdaPot] :: AdaPots -> Coin
[poolDepositAdaPot] :: AdaPots -> Coin
[depositsAdaPot] :: AdaPots -> Coin
[feesAdaPot] :: AdaPots -> Coin

-- | Calculate the total ada in the epoch state
totalAdaES :: EraTxOut era => EpochState era -> Coin

-- | Calculate the total ada pots in the epoch state
totalAdaPotsES :: EraTxOut era => EpochState era -> AdaPots
instance GHC.Generics.Generic Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance GHC.Show.Show Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance GHC.Classes.Eq Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance GHC.Generics.Generic Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance GHC.Show.Show Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance GHC.Classes.Eq Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool

module Cardano.Ledger.Shelley.API.Types
data () => Block h era
Block' :: !h -> !TxSeq era -> ByteString -> Block h era
pattern Block :: (Era era, EncCBORGroup (TxSeq era), EncCBOR h) => h -> TxSeq era -> Block h era
pattern UnsafeUnserialisedBlock :: h -> TxSeq era -> Block h era
pattern UnserialisedBlock :: h -> TxSeq era -> Block h era
data () => Ptr
Ptr :: !SlotNo -> !TxIx -> !CertIx -> Ptr
data () => Addr c
Addr :: Network -> PaymentCredential c -> StakeReference c -> Addr c
AddrBootstrap :: BootstrapAddress c -> Addr c

-- | <i>Deprecated: Use <a>ShelleyTxAuxData</a> instead</i>
type Metadata era = ShelleyTxAuxData era
data () => ProtVer
ProtVer :: !Version -> !Natural -> ProtVer
[pvMajor] :: ProtVer -> !Version
[pvMinor] :: ProtVer -> !Natural
data ShelleyTx era
pattern ShelleyTx :: EraTx era => TxBody era -> TxWits era -> StrictMaybe (TxAuxData era) -> ShelleyTx era
data ShelleyTxOut era
TxOutCompact :: {-# UNPACK #-} !CompactAddr (EraCrypto era) -> !CompactForm (Value era) -> ShelleyTxOut era
pattern ShelleyTxOut :: (HasCallStack, Era era, Val (Value era)) => Addr (EraCrypto era) -> Value era -> ShelleyTxOut era
newtype ShelleyTxBody era
TxBodyConstr :: MemoBytes ShelleyTxBodyRaw era -> ShelleyTxBody era

-- | Pattern for use by external users
pattern ShelleyTxBody :: (EraTxOut era, EncCBOR (TxCert era)) => Set (TxIn (EraCrypto era)) -> StrictSeq (TxOut era) -> StrictSeq (TxCert era) -> Withdrawals (EraCrypto era) -> Coin -> SlotNo -> StrictMaybe (Update era) -> StrictMaybe (AuxiliaryDataHash (EraCrypto era)) -> ShelleyTxBody era
data ShelleyTxAuxData era
pattern ShelleyTxAuxData :: forall era. Era era => Map Word64 Metadatum -> ShelleyTxAuxData era
newtype () => UTxO era
UTxO :: Map (TxIn (EraCrypto era)) (TxOut era) -> UTxO era
[unUTxO] :: UTxO era -> Map (TxIn (EraCrypto era)) (TxOut era)
type Hash c = Hash HASH c
data () => TxIx
newtype () => Coin
Coin :: Integer -> Coin
[unCoin] :: Coin -> Integer
data AccountState
AccountState :: !Coin -> !Coin -> AccountState
[asTreasury] :: AccountState -> !Coin
[asReserves] :: AccountState -> !Coin
data () => CertState era
CertState :: !VState era -> !PState era -> !DState era -> CertState era
[certVState] :: CertState era -> !VState era
[certPState] :: CertState era -> !PState era
[certDState] :: CertState era -> !DState era
data () => DState era
DState :: !UMap (EraCrypto era) -> !Map (FutureGenDeleg (EraCrypto era)) (GenDelegPair (EraCrypto era)) -> !GenDelegs (EraCrypto era) -> !InstantaneousRewards (EraCrypto era) -> DState era
[dsUnified] :: DState era -> !UMap (EraCrypto era)
[dsFutureGenDelegs] :: DState era -> !Map (FutureGenDeleg (EraCrypto era)) (GenDelegPair (EraCrypto era))
[dsGenDelegs] :: DState era -> !GenDelegs (EraCrypto era)
[dsIRewards] :: DState era -> !InstantaneousRewards (EraCrypto era)
data EpochState era
EpochState :: !AccountState -> !LedgerState era -> !SnapShots (EraCrypto era) -> !NonMyopic (EraCrypto era) -> EpochState era
[esAccountState] :: EpochState era -> !AccountState
[esLState] :: EpochState era -> !LedgerState era
[esSnapshots] :: EpochState era -> !SnapShots (EraCrypto era)

-- | This field, esNonMyopic, does not appear in the formal spec and is not
--   a part of the protocol. It is only used for providing data to the
--   stake pool ranking calculation <tt>getNonMyopicMemberRewards</tt>. See
--   <a>https://github.com/input-output-hk/cardano-ledger/releases/latest/download/pool-ranking.pdf</a>
[esNonMyopic] :: EpochState era -> !NonMyopic (EraCrypto era)
newtype () => GenDelegs c
GenDelegs :: Map (KeyHash 'Genesis c) (GenDelegPair c) -> GenDelegs c
[unGenDelegs] :: GenDelegs c -> Map (KeyHash 'Genesis c) (GenDelegPair c)

-- | The state associated with a <tt>Ledger</tt>.
data LedgerState era
LedgerState :: !UTxOState era -> !CertState era -> LedgerState era

-- | The current unspent transaction outputs.
[lsUTxOState] :: LedgerState era -> !UTxOState era
[lsCertState] :: LedgerState era -> !CertState era

-- | New Epoch state and environment
data NewEpochState era
NewEpochState :: !EpochNo -> !BlocksMade (EraCrypto era) -> !BlocksMade (EraCrypto era) -> !EpochState era -> !StrictMaybe (PulsingRewUpdate (EraCrypto era)) -> !PoolDistr (EraCrypto era) -> !StashedAVVMAddresses era -> NewEpochState era

-- | Last epoch
[nesEL] :: NewEpochState era -> !EpochNo

-- | Blocks made before current epoch
[nesBprev] :: NewEpochState era -> !BlocksMade (EraCrypto era)

-- | Blocks made in current epoch
[nesBcur] :: NewEpochState era -> !BlocksMade (EraCrypto era)

-- | Epoch state before current
[nesEs] :: NewEpochState era -> !EpochState era

-- | Possible reward update
[nesRu] :: NewEpochState era -> !StrictMaybe (PulsingRewUpdate (EraCrypto era))

-- | Stake distribution within the stake pool
[nesPd] :: NewEpochState era -> !PoolDistr (EraCrypto era)

-- | AVVM addresses to be removed at the end of the Shelley era. Note that
--   the existence of this field is a hack, related to the transition of
--   UTxO to disk. We remove AVVM addresses from the UTxO on the
--   Shelley/Allegra boundary. However, by this point the UTxO will be
--   moved to disk, and hence doing a scan of the UTxO for AVVM addresses
--   will be expensive. Our solution to this is to do a scan of the UTxO on
--   the Byron/Shelley boundary (since Byron UTxO are still on disk), stash
--   the results here, and then remove them at the Shelley/Allegra
--   boundary.
--   
--   This is very much an awkward implementation hack, and hence we hide it
--   from as many places as possible.
[stashedAVVMAddresses] :: NewEpochState era -> !StashedAVVMAddresses era
newtype () => PoolDistr c
PoolDistr :: Map (KeyHash 'StakePool c) (IndividualPoolStake c) -> PoolDistr c
[unPoolDistr] :: PoolDistr c -> Map (KeyHash 'StakePool c) (IndividualPoolStake c)

-- | Shelley genesis information
--   
--   Note that this is needed only for a pure Shelley network, hence it
--   being defined here rather than in its own module. In mainnet, Shelley
--   will transition naturally from Byron, and thus will never have its own
--   genesis information.
data ShelleyGenesis c
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTimeMicro -> !Word64 -> !Word64 -> !PParams (ShelleyEra c) -> !Map (KeyHash 'Genesis c) (GenDelegPair c) -> ListMap (Addr c) Coin -> ShelleyGenesisStaking c -> ShelleyGenesis c
[sgSystemStart] :: ShelleyGenesis c -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis c -> !Word32
[sgNetworkId] :: ShelleyGenesis c -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis c -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis c -> !Word64
[sgEpochLength] :: ShelleyGenesis c -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis c -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis c -> !Word64
[sgSlotLength] :: ShelleyGenesis c -> !NominalDiffTimeMicro
[sgUpdateQuorum] :: ShelleyGenesis c -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis c -> !Word64
[sgProtocolParams] :: ShelleyGenesis c -> !PParams (ShelleyEra c)
[sgGenDelegs] :: ShelleyGenesis c -> !Map (KeyHash 'Genesis c) (GenDelegPair c)

-- | <a>sgInitialFunds</a> is intentionally kept lazy, as it can otherwise
--   cause out-of-memory problems in testing and benchmarking.
[sgInitialFunds] :: ShelleyGenesis c -> ListMap (Addr c) Coin

-- | <a>sgStaking</a> is intentionally kept lazy, as it can otherwise cause
--   out-of-memory problems in testing and benchmarking.
[sgStaking] :: ShelleyGenesis c -> ShelleyGenesisStaking c
data () => StrictMaybe a
SNothing :: StrictMaybe a
SJust :: !a -> StrictMaybe a
data () => Globals
Globals :: !EpochInfo (Either Text) -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Version -> !Word64 -> !ActiveSlotCoeff -> !Network -> !SystemStart -> Globals
[epochInfo] :: Globals -> !EpochInfo (Either Text)
[slotsPerKESPeriod] :: Globals -> !Word64
[stabilityWindow] :: Globals -> !Word64
[randomnessStabilisationWindow] :: Globals -> !Word64
[securityParameter] :: Globals -> !Word64
[maxKESEvo] :: Globals -> !Word64
[quorum] :: Globals -> !Word64
[maxMajorPV] :: Globals -> !Version
[maxLovelaceSupply] :: Globals -> !Word64
[activeSlotCoeff] :: Globals -> !ActiveSlotCoeff
[networkId] :: Globals -> !Network
[systemStart] :: Globals -> !SystemStart
data () => Credential (kr :: KeyRole) c
ScriptHashObj :: !ScriptHash c -> Credential (kr :: KeyRole) c
KeyHashObj :: !KeyHash kr c -> Credential (kr :: KeyRole) c
newtype () => KeyHash (discriminator :: KeyRole) c
KeyHash :: Hash (ADDRHASH c) (VerKeyDSIGN (DSIGN c)) -> KeyHash (discriminator :: KeyRole) c
data () => KeyRole
Genesis :: KeyRole
GenesisDelegate :: KeyRole
Payment :: KeyRole
Staking :: KeyRole
StakePool :: KeyRole
BlockIssuer :: KeyRole
Witness :: KeyRole
DRepRole :: KeyRole
HotCommitteeRole :: KeyRole
ColdCommitteeRole :: KeyRole
data () => PState era
PState :: !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)) -> !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era)) -> !Map (KeyHash 'StakePool (EraCrypto era)) EpochNo -> !Map (KeyHash 'StakePool (EraCrypto era)) Coin -> PState era
[psStakePoolParams] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era))
[psFutureStakePoolParams] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) (PoolParams (EraCrypto era))
[psRetiring] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) EpochNo
[psDeposits] :: PState era -> !Map (KeyHash 'StakePool (EraCrypto era)) Coin

-- | The ultiate goal of a reward update computation. Aggregating rewards
--   for each staking credential.
data RewardUpdate c
RewardUpdate :: !DeltaCoin -> !DeltaCoin -> !Map (Credential 'Staking c) (Set (Reward c)) -> !DeltaCoin -> !NonMyopic c -> RewardUpdate c
[deltaT] :: RewardUpdate c -> !DeltaCoin
[deltaR] :: RewardUpdate c -> !DeltaCoin
[rs] :: RewardUpdate c -> !Map (Credential 'Staking c) (Set (Reward c))
[deltaF] :: RewardUpdate c -> !DeltaCoin
[nonMyopic] :: RewardUpdate c -> !NonMyopic c

-- | There is a serious invariant that we must maintain in the UTxOState.
--   Given (UTxOState utxo _ _ _ istake) it must be the case that istake ==
--   (updateStakeDistribution (UTxO Map.empty) (UTxO Map.empty) utxo) Of
--   course computing the RHS of the above equality can be very expensive,
--   so we only use this route in the testing function smartUTxO. But we
--   are very careful, wherever we update the UTxO, we carefully make
--   INCREMENTAL changes to istake to maintain this invariant. This happens
--   in the UTxO rule.
data UTxOState era
UTxOState :: !UTxO era -> Coin -> !Coin -> !GovState era -> !IncrementalStake (EraCrypto era) -> !Coin -> UTxOState era
[utxosUtxo] :: UTxOState era -> !UTxO era

-- | This field is left lazy, because we only use it for assertions
[utxosDeposited] :: UTxOState era -> Coin
[utxosFees] :: UTxOState era -> !Coin
[utxosGovState] :: UTxOState era -> !GovState era
[utxosStakeDistr] :: UTxOState era -> !IncrementalStake (EraCrypto era)
[utxosDonation] :: UTxOState era -> !Coin
data NonMyopic c
data () => PoolParams c
PoolParams :: !KeyHash 'StakePool c -> !Hash c (VerKeyVRF c) -> !Coin -> !Coin -> !UnitInterval -> !RewardAcnt c -> !Set (KeyHash 'Staking c) -> !StrictSeq StakePoolRelay -> !StrictMaybe PoolMetadata -> PoolParams c
[ppId] :: PoolParams c -> !KeyHash 'StakePool c
[ppVrf] :: PoolParams c -> !Hash c (VerKeyVRF c)
[ppPledge] :: PoolParams c -> !Coin
[ppCost] :: PoolParams c -> !Coin
[ppMargin] :: PoolParams c -> !UnitInterval
[ppRewardAcnt] :: PoolParams c -> !RewardAcnt c
[ppOwners] :: PoolParams c -> !Set (KeyHash 'Staking c)
[ppRelays] :: PoolParams c -> !StrictSeq StakePoolRelay
[ppMetadata] :: PoolParams c -> !StrictMaybe PoolMetadata
data () => WitVKey (kr :: KeyRole) c
pattern WitVKey :: (Typeable kr, Crypto c) => VKey kr c -> SignedDSIGN c (Hash c EraIndependentTxBody) -> WitVKey kr c
data () => TxIn c
TxIn :: !TxId c -> {-# UNPACK #-} !TxIx -> TxIn c
data LedgerEnv era
LedgerEnv :: !SlotNo -> !TxIx -> !PParams era -> !AccountState -> LedgerEnv era
[ledgerSlotNo] :: LedgerEnv era -> !SlotNo
[ledgerIx] :: LedgerEnv era -> !TxIx
[ledgerPp] :: LedgerEnv era -> !PParams era
[ledgerAccount] :: LedgerEnv era -> !AccountState
data () => RewardAcnt c
RewardAcnt :: !Network -> !Credential 'Staking c -> RewardAcnt c
[getRwdNetwork] :: RewardAcnt c -> !Network
[getRwdCred] :: RewardAcnt c -> !Credential 'Staking c
data () => CertIx
data () => Network
Testnet :: Network
Mainnet :: Network
data () => Nonce
Nonce :: !Hash Blake2b_256 Nonce -> Nonce
NeutralNonce :: Nonce
newtype () => Port
Port :: Word16 -> Port
[portToWord16] :: Port -> Word16
data () => StakeReference c
StakeRefBase :: !StakeCredential c -> StakeReference c
StakeRefPtr :: !Ptr -> StakeReference c
StakeRefNull :: StakeReference c
data () => SnapShot c
SnapShot :: !Stake c -> !VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c) -> !VMap VB VB (KeyHash 'StakePool c) (PoolParams c) -> SnapShot c
[$sel:ssStake:SnapShot] :: SnapShot c -> !Stake c
[$sel:ssDelegations:SnapShot] :: SnapShot c -> !VMap VB VB (Credential 'Staking c) (KeyHash 'StakePool c)
[$sel:ssPoolParams:SnapShot] :: SnapShot c -> !VMap VB VB (KeyHash 'StakePool c) (PoolParams c)
data () => SnapShots c
SnapShots :: SnapShot c -> PoolDistr c -> !SnapShot c -> !SnapShot c -> !Coin -> SnapShots c
[$sel:ssStakeMark:SnapShots] :: SnapShots c -> SnapShot c
[$sel:ssStakeMarkPoolDistr:SnapShots] :: SnapShots c -> PoolDistr c
[$sel:ssStakeSet:SnapShots] :: SnapShots c -> !SnapShot c
[$sel:ssStakeGo:SnapShots] :: SnapShots c -> !SnapShot c
[$sel:ssFee:SnapShots] :: SnapShots c -> !Coin
newtype () => Stake c
Stake :: VMap VB VP (Credential 'Staking c) (CompactForm Coin) -> Stake c
[$sel:unStake:Stake] :: Stake c -> VMap VB VP (Credential 'Staking c) (CompactForm Coin)
type CertifiedVRF c = CertifiedVRF VRF c
data () => GenDelegPair c
GenDelegPair :: !KeyHash 'GenesisDelegate c -> !Hash c (VerKeyVRF c) -> GenDelegPair c
[genDelegKeyHash] :: GenDelegPair c -> !KeyHash 'GenesisDelegate c
[genDelegVrfHash] :: GenDelegPair c -> !Hash c (VerKeyVRF c)
type KESignable c = Signable KES c
data () => KeyPair (kd :: KeyRole) c
KeyPair :: !VKey kd c -> !SignKeyDSIGN (DSIGN c) -> KeyPair (kd :: KeyRole) c
[vKey] :: KeyPair (kd :: KeyRole) c -> !VKey kd c
[sKey] :: KeyPair (kd :: KeyRole) c -> !SignKeyDSIGN (DSIGN c)
type SignKeyDSIGN c = SignKeyDSIGN DSIGN c
type SignKeyKES c = SignKeyKES KES c
type SignKeyVRF c = SignKeyVRF VRF c
type SignedDSIGN c = SignedDSIGN DSIGN c
type SignedKES c = SignedKES KES c
newtype () => VKey (kd :: KeyRole) c
VKey :: VerKeyDSIGN (DSIGN c) -> VKey (kd :: KeyRole) c
[unVKey] :: VKey (kd :: KeyRole) c -> VerKeyDSIGN (DSIGN c)
type VerKeyKES c = VerKeyKES KES c
type VerKeyVRF c = VerKeyVRF VRF c
data () => BootstrapWitness c
pattern BootstrapWitness :: Crypto c => VKey 'Witness c -> SignedDSIGN c (Hash c EraIndependentTxBody) -> ChainCode -> ByteString -> BootstrapWitness c

-- | Incremental Stake, Stake along with possible missed coins from danging
--   Ptrs. Transactions can use Ptrs to refer to a stake credential in a
--   TxOut. The Ptr does not have to point to anything until the epoch
--   boundary, when we compute rewards and aggregate staking information
--   for ranking. This is unusual but legal. In a non incremental system,
--   we use whatever <tt>legal</tt> Ptrs exist at the epoch boundary. Here
--   we are computing things incrementally, so we need to remember Ptrs
--   that might point to something by the time the epoch boundary is
--   reached. When the epoch boundary is reached we <tt>resolve</tt> these
--   pointers, to see if any have become non-dangling since the time they
--   were first used in the incremental computation.
data IncrementalStake c
IStake :: !Map (Credential 'Staking c) (CompactForm Coin) -> !Map Ptr (CompactForm Coin) -> IncrementalStake c
[credMap] :: IncrementalStake c -> !Map (Credential 'Staking c) (CompactForm Coin)
[ptrMap] :: IncrementalStake c -> !Map Ptr (CompactForm Coin)
data () => InstantaneousRewards c
InstantaneousRewards :: !Map (Credential 'Staking c) Coin -> !Map (Credential 'Staking c) Coin -> !DeltaCoin -> !DeltaCoin -> InstantaneousRewards c
[iRReserves] :: InstantaneousRewards c -> !Map (Credential 'Staking c) Coin
[iRTreasury] :: InstantaneousRewards c -> !Map (Credential 'Staking c) Coin
[deltaReserves] :: InstantaneousRewards c -> !DeltaCoin
[deltaTreasury] :: InstantaneousRewards c -> !DeltaCoin

-- | <i>Deprecated: Use `Test.Cardano.Ledger.Core.KeyPair (KeyPairs)`
--   instead</i>
type KeyPairs c = [(KeyPair 'Payment c, KeyPair 'Staking c)]
data ShelleyGovState era
ShelleyGovState :: !ProposedPPUpdates era -> !ProposedPPUpdates era -> !PParams era -> !PParams era -> ShelleyGovState era
[proposals] :: ShelleyGovState era -> !ProposedPPUpdates era
[futureProposals] :: ShelleyGovState era -> !ProposedPPUpdates era
[sgovPp] :: ShelleyGovState era -> !PParams era
[sgovPrevPp] :: ShelleyGovState era -> !PParams era
data () => VState era
VState :: !Map (Credential 'DRepRole (EraCrypto era)) (DRepState (EraCrypto era)) -> !CommitteeState era -> EpochNo -> VState era
[vsDReps] :: VState era -> !Map (Credential 'DRepRole (EraCrypto era)) (DRepState (EraCrypto era))
[vsCommitteeState] :: VState era -> !CommitteeState era
[vsNumDormantEpochs] :: VState era -> EpochNo

-- | Update operation for protocol parameters structure <tt>PParams</tt>
newtype ProposedPPUpdates era
ProposedPPUpdates :: Map (KeyHash 'Genesis (EraCrypto era)) (PParamsUpdate era) -> ProposedPPUpdates era

-- | Update Proposal
data Update era
Update :: !ProposedPPUpdates era -> !EpochNo -> Update era
data DelegEnv era
DelegEnv :: SlotNo -> Ptr -> AccountState -> PParams era -> DelegEnv era
[slotNo] :: DelegEnv era -> SlotNo
[ptr_] :: DelegEnv era -> Ptr
[acnt_] :: DelegEnv era -> AccountState
[ppDE] :: DelegEnv era -> PParams era
data ShelleyDELEG era
data DelegsEnv era
DelegsEnv :: !SlotNo -> !TxIx -> !PParams era -> !Tx era -> !AccountState -> DelegsEnv era
[delegsSlotNo] :: DelegsEnv era -> !SlotNo
[delegsIx] :: DelegsEnv era -> !TxIx
[delegspp] :: DelegsEnv era -> !PParams era
[delegsTx] :: DelegsEnv era -> !Tx era
[delegsAccount] :: DelegsEnv era -> !AccountState
data ShelleyDELEGS era
data DelplEnv era
DelplEnv :: SlotNo -> Ptr -> PParams era -> AccountState -> DelplEnv era
[delplSlotNo] :: DelplEnv era -> SlotNo
[delPlPtr] :: DelplEnv era -> Ptr
[delPlPp] :: DelplEnv era -> PParams era
[delPlAcnt] :: DelplEnv era -> AccountState
data ShelleyDELPL era
data ShelleyLEDGER era
data ShelleyLEDGERS era
data ShelleyLedgersEnv era
LedgersEnv :: SlotNo -> PParams era -> AccountState -> ShelleyLedgersEnv era
[ledgersSlotNo] :: ShelleyLedgersEnv era -> SlotNo
[ledgersPp] :: ShelleyLedgersEnv era -> PParams era
[ledgersAccount] :: ShelleyLedgersEnv era -> AccountState
data ShelleyNEWEPOCH era
data PoolEnv era
PoolEnv :: !SlotNo -> !PParams era -> PoolEnv era
data ShelleyPOOL era
data ShelleyPOOLREAP era
data PpupEnv era
PPUPEnv :: SlotNo -> PParams era -> GenDelegs (EraCrypto era) -> PpupEnv era
data ShelleyPPUP era
data SnapEnv era
SnapEnv :: !LedgerState era -> !PParams era -> SnapEnv era
data ShelleyTICK era
data ShelleyTICKF era
data ShelleyUTXO era
data UtxoEnv era
UtxoEnv :: SlotNo -> PParams era -> CertState era -> GenDelegs (EraCrypto era) -> UtxoEnv era
[ueSlot] :: UtxoEnv era -> SlotNo
[uePParams] :: UtxoEnv era -> PParams era
[ueCertState] :: UtxoEnv era -> CertState era
[ueGenDelegs] :: UtxoEnv era -> GenDelegs (EraCrypto era)
data ShelleyUTXOW era
data MultiSig era
pattern RequireAllOf :: Era era => [MultiSig era] -> MultiSig era
pattern RequireAnyOf :: Era era => [MultiSig era] -> MultiSig era
pattern RequireSignature :: Era era => KeyHash 'Witness (EraCrypto era) -> MultiSig era
pattern RequireMOf :: Era era => Int -> [MultiSig era] -> MultiSig era
newtype () => ScriptHash c
ScriptHash :: Hash (ADDRHASH c) EraIndependentScript -> ScriptHash c

-- | A generic metadatum type.
data Metadatum
Map :: ![(Metadatum, Metadatum)] -> Metadatum
List :: ![Metadatum] -> Metadatum
I :: !Integer -> Metadatum
B :: !ByteString -> Metadatum
S :: !Text -> Metadatum
data () => Delegation c
Delegation :: !StakeCredential c -> !KeyHash 'StakePool c -> Delegation c
[dDelegator] :: Delegation c -> !StakeCredential c
[dDelegatee] :: Delegation c -> !KeyHash 'StakePool c

-- | Genesis key delegation certificate
data GenesisDelegCert c
GenesisDelegCert :: !KeyHash 'Genesis c -> !KeyHash 'GenesisDelegate c -> !Hash c (VerKeyVRF c) -> GenesisDelegCert c

-- | Move instantaneous rewards certificate
data MIRCert c
MIRCert :: !MIRPot -> !MIRTarget c -> MIRCert c
[mirPot] :: MIRCert c -> !MIRPot
[mirRewards] :: MIRCert c -> !MIRTarget c
data MIRPot
ReservesMIR :: MIRPot
TreasuryMIR :: MIRPot

-- | MIRTarget specifies if funds from either the reserves or the treasury
--   are to be handed out to a collection of reward accounts or instead
--   transfered to the opposite pot.
data MIRTarget c
StakeAddressesMIR :: !Map (Credential 'Staking c) DeltaCoin -> MIRTarget c
SendToOppositePotMIR :: !Coin -> MIRTarget c
data () => PoolMetadata
PoolMetadata :: !Url -> !ByteString -> PoolMetadata
[pmUrl] :: PoolMetadata -> !Url
[pmHash] :: PoolMetadata -> !ByteString
data () => StakePoolRelay
SingleHostAddr :: !StrictMaybe Port -> !StrictMaybe IPv4 -> !StrictMaybe IPv6 -> StakePoolRelay
SingleHostName :: !StrictMaybe Port -> !DnsName -> StakePoolRelay
MultiHostName :: !DnsName -> StakePoolRelay
newtype () => Withdrawals c
Withdrawals :: Map (RewardAcnt c) Coin -> Withdrawals c
[unWithdrawals] :: Withdrawals c -> Map (RewardAcnt c) Coin
data () => PoolCert c
RegPool :: !PoolParams c -> PoolCert c
RetirePool :: !KeyHash 'StakePool c -> !EpochNo -> PoolCert c
data ShelleyDelegCert c

-- | A stake credential registration certificate.
ShelleyRegCert :: !StakeCredential c -> ShelleyDelegCert c

-- | A stake credential deregistration certificate.
ShelleyUnRegCert :: !StakeCredential c -> ShelleyDelegCert c

-- | A stake delegation certificate.
ShelleyDelegCert :: !StakeCredential c -> !KeyHash 'StakePool c -> ShelleyDelegCert c

-- | <i>Deprecated: In favor of <a>ShelleyRegCert</a></i>
pattern RegKey :: StakeCredential c -> ShelleyDelegCert c

-- | <i>Deprecated: In favor of <a>ShelleyUnRegCert</a></i>
pattern DeRegKey :: StakeCredential c -> ShelleyDelegCert c

-- | <i>Deprecated: In favor of <a>ShelleyDelegCert</a></i>
pattern Delegate :: Delegation c -> ShelleyDelegCert c
data ShelleyTxWits era
newtype () => TxId c
TxId :: SafeHash c EraIndependentTxBody -> TxId c
[unTxId] :: TxId c -> SafeHash c EraIndependentTxBody

-- | Genesis Shelley staking configuration.
--   
--   This allows us to configure some initial stake pools and delegation to
--   them, in order to test Praos in a static configuration, without
--   requiring on-chain registration and delegation.
--   
--   For simplicity, pools defined in the genesis staking do not pay
--   deposits for their registration.
data ShelleyGenesisStaking c
ShelleyGenesisStaking :: ListMap (KeyHash 'StakePool c) (PoolParams c) -> ListMap (KeyHash 'Staking c) (KeyHash 'StakePool c) -> ShelleyGenesisStaking c

-- | Pools to register
--   
--   The key in this map is the hash of the public key of the _pool_. This
--   need not correspond to any payment or staking key, but must correspond
--   to the cold key held by <tt>TPraosIsCoreNode</tt>.
[sgsPools] :: ShelleyGenesisStaking c -> ListMap (KeyHash 'StakePool c) (PoolParams c)

-- | Stake-holding key hash credentials and the pools to delegate that
--   stake to. We require the raw staking key hash in order to:
--   
--   <ul>
--   <li>Avoid pointer addresses, which would be tricky when there's no
--   slot or transaction to point to.</li>
--   <li>Avoid script credentials.</li>
--   </ul>
[sgsStake] :: ShelleyGenesisStaking c -> ListMap (KeyHash 'Staking c) (KeyHash 'StakePool c)
data ValidationErr
EpochNotLongEnough :: EpochSize -> Word64 -> Rational -> EpochSize -> ValidationErr
MaxKESEvolutionsUnsupported :: Word64 -> Word -> ValidationErr
QuorumTooSmall :: Word64 -> Word64 -> Word64 -> ValidationErr

-- | Unlike <tt><a>NominalDiffTime</a></tt> that supports
--   <tt><a>Pico</a></tt> precision, this type only supports
--   <tt><a>Micro</a></tt> precision.
newtype NominalDiffTimeMicro
NominalDiffTimeMicro :: Micro -> NominalDiffTimeMicro
balance :: EraTxOut era => UTxO era -> Value era
genesisUTxO :: forall era. EraTxOut era => ShelleyGenesis (EraCrypto era) -> UTxO era
word64ToCoin :: Word64 -> Coin
calculatePoolDistr :: SnapShot c -> PoolDistr c
isOverlaySlot :: SlotNo -> UnitInterval -> SlotNo -> Bool
certIxFromIntegral :: Integral a => a -> Maybe CertIx
certIxToInt :: CertIx -> Int
txIxFromIntegral :: Integral a => a -> Maybe TxIx
txIxToInt :: TxIx -> Int
bbody :: Block h era -> TxSeq era
bheader :: Block h era -> h
coerceKeyRole :: forall (r :: KeyRole) c (r' :: KeyRole). HasKeyRole a => a r c -> a r' c
hashKey :: forall c (kd :: KeyRole). Crypto c => VKey kd c -> KeyHash kd c
hashVerKeyVRF :: (VRFAlgorithm v, HashAlgorithm h) => VerKeyVRF v -> Hash h (VerKeyVRF v)
individualPoolStake :: IndividualPoolStake c -> Rational

-- | Hash a given block body
bbHash :: forall era. Era era => ShelleyTxSeq era -> Hash (EraCrypto era) EraIndependentBlockBody
calculatePoolDistr' :: (KeyHash 'StakePool c -> Bool) -> SnapShot c -> PoolDistr c

-- | Calculate the randomness stabilisation window from the security param
--   and the active slot coefficient.
--   
--   The value 4k/f is determined to be a suitabe value as per
--   <a>https://docs.google.com/document/d/1B8BNMx8jVWRjYiUBOaI3jfZ7dQNvNTSDODvT5iOuYCU/edit#heading=h.qh2zcajmu6hm</a>
computeRandomnessStabilisationWindow :: Word64 -> ActiveSlotCoeff -> Word64

-- | Calculate the stability window (e.g. the number of slots needed for a
--   block to become stable) from the security param and the active slot
--   coefficient.
--   
--   The value 3k/f is determined to be a suitabe value as per
--   <a>https://docs.google.com/document/d/1B8BNMx8jVWRjYiUBOaI3jfZ7dQNvNTSDODvT5iOuYCU/edit#heading=h.qh2zcajmu6hm</a>
computeStabilityWindow :: Word64 -> ActiveSlotCoeff -> Word64
toShelleyGenesisPairs :: (KeyValue a, Crypto c) => ShelleyGenesis c -> [a]

-- | Empty genesis staking
emptyGenesisStaking :: ShelleyGenesisStaking c
sgActiveSlotCoeff :: ShelleyGenesis c -> ActiveSlotCoeff

-- | Compute the <a>TxIn</a> of the initial UTxO pseudo-transaction
--   corresponding to the given address in the genesis initial funds.
--   
--   The Shelley initial UTxO is constructed from the <a>sgInitialFunds</a>
--   which is not a full UTxO but just a map from addresses to coin values.
--   
--   This gets turned into a UTxO by making a pseudo-transaction for each
--   address, with the 0th output being the coin value. So to spend from
--   the initial UTxO we need this same <a>TxIn</a> to use as an input to
--   the spending transaction.
initialFundsPseudoTxIn :: forall c. Crypto c => Addr c -> TxIn c

-- | Do some basic sanity checking on the Shelley genesis file.
validateGenesis :: forall c. Crypto c => ShelleyGenesis c -> Either [ValidationErr] ()
describeValidationErr :: ValidationErr -> Text
mkShelleyGlobals :: ShelleyGenesis c -> EpochInfo (Either Text) -> Version -> Globals
nominalDiffTimeMicroToMicroseconds :: NominalDiffTimeMicro -> Micro
nominalDiffTimeMicroToSeconds :: NominalDiffTimeMicro -> Pico
toNominalDiffTimeMicro :: NominalDiffTime -> Maybe NominalDiffTimeMicro
toNominalDiffTimeMicroWithRounding :: NominalDiffTime -> NominalDiffTimeMicro
fromNominalDiffTimeMicro :: NominalDiffTimeMicro -> NominalDiffTime
secondsToNominalDiffTimeMicro :: Micro -> NominalDiffTimeMicro

module Cardano.Ledger.Shelley
type Shelley = ShelleyEra StandardCrypto
data ShelleyEra c
data ShelleyTx era
data ShelleyTxOut era
data ShelleyTxBody era
data ShelleyTxAuxData era

-- | Magic number "memorialized" in the ValidateScript class under the
--   method: scriptPrefixTag:: Core.Script era -&gt; Bs.ByteString, for the
--   Shelley Era.
nativeMultiSigTag :: ByteString


-- | Interface to the block validation and chain extension logic in the
--   Shelley API.
module Cardano.Ledger.Shelley.API.Validation
class (STS (EraRule "TICK" era), BaseM (EraRule "TICK" era) ~ ShelleyBase, Environment (EraRule "TICK" era) ~ (), State (EraRule "TICK" era) ~ NewEpochState era, Signal (EraRule "TICK" era) ~ SlotNo, STS (EraRule "BBODY" era), BaseM (EraRule "BBODY" era) ~ ShelleyBase, Environment (EraRule "BBODY" era) ~ BbodyEnv era, State (EraRule "BBODY" era) ~ ShelleyBbodyState era, Signal (EraRule "BBODY" era) ~ Block (BHeaderView (EraCrypto era)) era, EncCBORGroup (TxSeq era), State (EraRule "LEDGERS" era) ~ LedgerState era) => ApplyBlock era

-- | Apply the header level ledger transition.
--   
--   This handles checks and updates that happen on a slot tick, as well as
--   a few header level checks, such as size constraints.
applyTickOpts :: ApplyBlock era => ApplySTSOpts ep -> Globals -> NewEpochState era -> SlotNo -> EventReturnType ep (EraRule "TICK" era) (NewEpochState era)

-- | Apply the block level ledger transition.
applyBlockOpts :: forall ep m. (ApplyBlock era, EventReturnTypeRep ep, MonadError (BlockTransitionError era) m) => ApplySTSOpts ep -> Globals -> NewEpochState era -> Block (BHeaderView (EraCrypto era)) era -> m (EventReturnType ep (EraRule "BBODY" era) (NewEpochState era))

-- | Apply the block level ledger transition.
applyBlockOpts :: forall ep m. (ApplyBlock era, EventReturnTypeRep ep, MonadError (BlockTransitionError era) m, EraGov era) => ApplySTSOpts ep -> Globals -> NewEpochState era -> Block (BHeaderView (EraCrypto era)) era -> m (EventReturnType ep (EraRule "BBODY" era) (NewEpochState era))

-- | Re-apply a ledger block to the same state it has been applied to
--   before.
--   
--   This function does no validation of whether the block applies
--   successfully; the caller implicitly guarantees that they have
--   previously called <tt>applyBlockTransition</tt> on the same block and
--   that this was successful.
reapplyBlock :: ApplyBlock era => Globals -> NewEpochState era -> Block (BHeaderView (EraCrypto era)) era -> NewEpochState era

-- | Re-apply a ledger block to the same state it has been applied to
--   before.
--   
--   This function does no validation of whether the block applies
--   successfully; the caller implicitly guarantees that they have
--   previously called <tt>applyBlockTransition</tt> on the same block and
--   that this was successful.
reapplyBlock :: (ApplyBlock era, EraGov era) => Globals -> NewEpochState era -> Block (BHeaderView (EraCrypto era)) era -> NewEpochState era
applyBlock :: (ApplyBlock era, MonadError (BlockTransitionError era) m) => Globals -> NewEpochState era -> Block (BHeaderView (EraCrypto era)) era -> m (NewEpochState era)
applyTick :: ApplyBlock era => Globals -> NewEpochState era -> SlotNo -> NewEpochState era
newtype TickTransitionError era
TickTransitionError :: [PredicateFailure (EraRule "TICK" era)] -> TickTransitionError era
newtype BlockTransitionError era
BlockTransitionError :: [PredicateFailure (EraRule "BBODY" era)] -> BlockTransitionError era
chainChecks :: forall c m. MonadError ChainPredicateFailure m => Version -> ChainChecksPParams -> BHeaderView c -> m ()

-- | <i>Deprecated: Constraint synonyms are being removed</i>
type ShelleyEraCrypto c = (Crypto c, DSignable c (Hash c EraIndependentTxBody))
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.API.Validation.TickTransitionError era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.API.Validation.BlockTransitionError era)
instance GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICK" era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.API.Validation.TickTransitionError era)
instance GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICK" era)) => GHC.Show.Show (Cardano.Ledger.Shelley.API.Validation.TickTransitionError era)
instance GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "BBODY" era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.API.Validation.BlockTransitionError era)
instance GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "BBODY" era)) => GHC.Show.Show (Cardano.Ledger.Shelley.API.Validation.BlockTransitionError era)
instance (Cardano.Ledger.Crypto.Crypto c, Cardano.Ledger.Keys.DSignable c (Cardano.Ledger.Keys.Hash c Cardano.Ledger.Hashes.EraIndependentTxBody)) => Cardano.Ledger.Shelley.API.Validation.ApplyBlock (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "BBODY" era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.API.Validation.BlockTransitionError era)
instance NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICK" era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.API.Validation.TickTransitionError era)


-- | Interface to the Shelley ledger for the purposes of managing a Shelley
--   mempool.
module Cardano.Ledger.Shelley.API.Mempool
class (EraTx era, Eq (ApplyTxError era), Show (ApplyTxError era), Typeable (ApplyTxError era), STS (EraRule "LEDGER" era), BaseM (EraRule "LEDGER" era) ~ ShelleyBase, Environment (EraRule "LEDGER" era) ~ LedgerEnv era, State (EraRule "LEDGER" era) ~ MempoolState era, Signal (EraRule "LEDGER" era) ~ Tx era) => ApplyTx era

-- | Validate a transaction against a mempool state, and return both the
--   new mempool state and a "validated" <tt>TxInBlock</tt>.
--   
--   The meaning of being "validated" depends on the era. In general, a
--   <tt>TxInBlock</tt> has had all checks run, and can now only fail due
--   to checks which depend on the state; most notably, that UTxO inputs
--   disappear.
applyTx :: (ApplyTx era, MonadError (ApplyTxError era) m) => Globals -> MempoolEnv era -> MempoolState era -> Tx era -> m (MempoolState era, Validated (Tx era))

-- | Reapply a previously validated <a>Tx</a>.
--   
--   This applies the (validated) transaction to a new mempool state. It
--   may fail due to the mempool state changing (for example, a needed
--   output having already been spent). It should not fail due to any
--   static check (such as cryptographic checks).
--   
--   Implementations of this function may optionally skip the performance
--   of any static checks. This is not required, but strongly encouraged
--   since this function will be called each time the mempool revalidates
--   transactions against a new mempool state.
reapplyTx :: (ApplyTx era, MonadError (ApplyTxError era) m) => Globals -> MempoolEnv era -> MempoolState era -> Validated (Tx era) -> m (MempoolState era)
newtype ApplyTxError era
ApplyTxError :: [PredicateFailure (EraRule "LEDGER" era)] -> ApplyTxError era

-- | A newtype which indicates that a transaction has been validated
--   against some chain state.
data Validated tx

-- | Extract the underlying unvalidated Tx.
extractTx :: Validated tx -> tx
coerceValidated :: Coercible a b => Validated a -> Validated b

-- | Translate a validated transaction across eras.
--   
--   This is not a <a>TranslateEra</a> instance since <a>Validated</a> is
--   not itself era-parametrised.
translateValidated :: forall era f. TranslateEra era f => TranslationContext era -> Validated (f (PreviousEra era)) -> Except (TranslationError era f) (Validated (f era))
type MempoolEnv era = LedgerEnv era
type MempoolState era = LedgerState era
applyTxsTransition :: forall era m. (ApplyTx era, MonadError (ApplyTxError era) m) => Globals -> MempoolEnv era -> Seq (Tx era) -> MempoolState era -> m (MempoolState era)
unsafeMakeValidated :: tx -> Validated tx

-- | Old <a>applyTxs</a>
applyTxs :: (ApplyTx era, MonadError (ApplyTxError era) m, EraGov era) => Globals -> SlotNo -> Seq (Tx era) -> NewEpochState era -> m (NewEpochState era)

-- | Construct the environment used to validate transactions from the full
--   ledger state.
--   
--   Note that this function also takes a slot. During slot validation, the
--   slot given here is the slot of the block containing the transactions.
--   This slot is used for quite a number of things, but in general these
--   do not determine the validity of the transaction. There are two
--   exceptions:
--   
--   <ul>
--   <li>Each transaction has a ttl (time-to-live) value. If the slot is
--   beyond this value, then the transaction is invalid.</li>
--   <li>If the transaction contains a protocol update proposal, then it
--   may only be included until a certain number of slots before the end of
--   the epoch. A protocol update proposal submitted after this is
--   considered invalid.</li>
--   </ul>
mkMempoolEnv :: EraGov era => NewEpochState era -> SlotNo -> MempoolEnv era

-- | Construct a mempool state from the wider ledger state.
--   
--   The given mempool state may then be evolved using <a>applyTxs</a>, but
--   should be regenerated when the ledger state gets updated (e.g. through
--   application of a new block).
mkMempoolState :: NewEpochState era -> MempoolState era

-- | Transform a function over mempool states to one over the full
--   <a>NewEpochState</a>.
overNewEpochState :: Functor f => (MempoolState era -> f (MempoolState era)) -> NewEpochState era -> f (NewEpochState era)
instance Control.DeepSeq.NFData tx => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.API.Mempool.Validated tx)
instance GHC.Show.Show tx => GHC.Show.Show (Cardano.Ledger.Shelley.API.Mempool.Validated tx)
instance NoThunks.Class.NoThunks tx => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.API.Mempool.Validated tx)
instance GHC.Classes.Eq tx => GHC.Classes.Eq (Cardano.Ledger.Shelley.API.Mempool.Validated tx)
instance GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era)) => GHC.Show.Show (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance (Cardano.Ledger.Core.PParams.EraPParams (Cardano.Ledger.Shelley.Era.ShelleyEra c), Cardano.Ledger.Keys.DSignable c (Cardano.Ledger.Keys.Hash c Cardano.Ledger.Hashes.EraIndependentTxBody)) => Cardano.Ledger.Shelley.API.Mempool.ApplyTx (Cardano.Ledger.Shelley.Era.ShelleyEra c)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Encoding.EncCBOR.EncCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance (Cardano.Ledger.Core.Era.Era era, Cardano.Ledger.Binary.Decoding.DecCBOR.DecCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)

module Cardano.Ledger.Shelley.API.Genesis

-- | Indicates that this era may be bootstrapped from
--   <a>ShelleyGenesis</a>.

-- | <i>Deprecated: Use <a>EraTransition</a> instead</i>
class (EraTxOut era, Default (StashedAVVMAddresses era), EraGov era) => CanStartFromGenesis era where {
    
    -- | Additional genesis configuration necessary for this era.
    type AdditionalGenesisConfig era :: Type;
    type AdditionalGenesisConfig era = ();
}

-- | Upgrade <a>PParams</a> from <a>ShelleyEra</a> all the way to the
--   current one.

-- | <i>Deprecated: Use <a>tcInitialPParamsG</a> instead</i>
fromShelleyPParams :: CanStartFromGenesis era => AdditionalGenesisConfig era -> PParams (ShelleyEra (EraCrypto era)) -> PParams era

-- | Construct an initial state given a <a>ShelleyGenesis</a> and any
--   appropriate <a>AdditionalGenesisConfig</a> for the era.

-- | <i>Deprecated: Use <a>createInitialState</a> instead</i>
initialState :: CanStartFromGenesis era => ShelleyGenesis (EraCrypto era) -> AdditionalGenesisConfig era -> NewEpochState era

-- | Helper function for constructing the initial state for any era
initialStateFromGenesis :: forall era. CanStartFromGenesis era => ShelleyGenesis (EraCrypto era) -> AdditionalGenesisConfig era -> NewEpochState era
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.API.Genesis.CanStartFromGenesis (Cardano.Ledger.Shelley.Era.ShelleyEra c)

module Cardano.Ledger.Shelley.API.ByronTranslation
translateToShelleyLedgerState :: forall c. (Crypto c, ADDRHASH c ~ Blake2b_224) => FromByronTranslationContext c -> EpochNo -> ChainValidationState -> NewEpochState (ShelleyEra c)
translateCompactTxOutByronToShelley :: CompactTxOut -> ShelleyTxOut (ShelleyEra c)

-- | We use the same hashing algorithm so we can unwrap and rewrap the
--   bytes. We don't care about the type that is hashed, which will differ
--   going from Byron to Shelley, we just use the hashes as IDs.
translateTxIdByronToShelley :: (Crypto c, ADDRHASH c ~ Blake2b_224) => TxId -> TxId c


-- | API to the Shelley ledger
module Cardano.Ledger.Shelley.API
