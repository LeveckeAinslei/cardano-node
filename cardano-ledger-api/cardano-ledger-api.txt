-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Public API for the cardano ledger codebase
--   
--   This package a public interface into the cardano ledger codebase. It
--   also provides functionality that works for all eras and is useful for
--   downstream packages.
@package cardano-ledger-api
@version 1.7.0.0

module Cardano.Ledger.Api.Era
class (Crypto EraCrypto era, Typeable era, KnownNat ProtVerLow era, KnownNat ProtVerHigh era, ProtVerLow era <= ProtVerHigh era, MinVersion <= ProtVerLow era, MinVersion <= ProtVerHigh era, CmpNat ProtVerLow era MaxVersion ~ 'LT, CmpNat ProtVerHigh era MaxVersion ~ 'LT, ProtVerLow era <= MaxVersion, ProtVerHigh era <= MaxVersion) => Era era where {
    type family PreviousEra era = (r :: Type) | r -> era;
    type family ProtVerLow era :: Nat;
    type family ProtVerHigh era :: Nat;
    type ProtVerHigh era = ProtVerLow era;
}
eraName :: Era era => String
data () => ByronEra c
type Shelley = ShelleyEra StandardCrypto
data () => ShelleyEra c
type Allegra = AllegraEra StandardCrypto
data () => AllegraEra c
type Mary = MaryEra StandardCrypto
data () => MaryEra era
type Alonzo = AlonzoEra StandardCrypto
data () => AlonzoEra c
type Babbage = BabbageEra StandardCrypto
data () => BabbageEra c
type Conway = ConwayEra StandardCrypto
data () => ConwayEra c

-- | Sometimes it is useful to specify that a type corresponds to a latest
--   era that is currently implemented
type LatestKnownEra c = ConwayEra c
data () => StandardCrypto
class (HashAlgorithm HASH c, HashAlgorithm ADDRHASH c, DSIGNAlgorithm DSIGN c, KESAlgorithm KES c, VRFAlgorithm VRF c, ContextDSIGN DSIGN c ~ (), ContextKES KES c ~ (), ContextVRF VRF c ~ (), Typeable c) => Crypto c where {
    type family HASH c;
    type family ADDRHASH c;
    type family DSIGN c;
    type family KES c;
    type family VRF c;
}
eraProtVerHigh :: Era era => Version
eraProtVerLow :: Era era => Version
type AtLeastEra (eraName :: Type -> Type) era = ProtVerAtLeast era ProtVerLow eraName EraCrypto era
type AtMostEra (eraName :: Type -> Type) era = ProtVerAtMost era ProtVerHigh eraName EraCrypto era
type ExactEra (inEra :: Type -> Type) era = ProtVerInBounds era ProtVerLow inEra EraCrypto era ProtVerHigh inEra EraCrypto era
type family ProtVerAtLeast era (l :: Nat)
type family ProtVerAtMost era (h :: Nat)
type ProtVerInBounds era (l :: Nat) (h :: Nat) = (ProtVerAtLeast era l, ProtVerAtMost era h)
atLeastEra :: forall (eraName :: Type -> Type) era. AtLeastEra eraName era => ()
atMostEra :: forall (eraName :: Type -> Type) era. AtMostEra eraName era => ()

module Cardano.Ledger.Api.Governance
class (EraPParams era, Eq GovState era, Show GovState era, NoThunks GovState era, NFData GovState era, EncCBOR GovState era, DecCBOR GovState era, DecShareCBOR GovState era, ToCBOR GovState era, FromCBOR GovState era, Default GovState era, ToJSON GovState era) => EraGov era where {
    type family GovState era = (r :: Type) | r -> era;
}
emptyGovState :: EraGov era => GovState era
getProposedPPUpdates :: EraGov era => GovState era -> Maybe (ProposedPPUpdates era)
data () => ShelleyGovState era
ShelleyGovState :: !ProposedPPUpdates era -> !ProposedPPUpdates era -> !PParams era -> !PParams era -> ShelleyGovState era
[proposals] :: ShelleyGovState era -> !ProposedPPUpdates era
[futureProposals] :: ShelleyGovState era -> !ProposedPPUpdates era
[sgovPp] :: ShelleyGovState era -> !PParams era
[sgovPrevPp] :: ShelleyGovState era -> !PParams era
newtype () => ProposedPPUpdates era
ProposedPPUpdates :: Map (KeyHash 'Genesis (EraCrypto era)) (PParamsUpdate era) -> ProposedPPUpdates era
emptyPPPUpdates :: ProposedPPUpdates era
data () => VotingProcedure era
VotingProcedure :: !Vote -> !StrictMaybe (Anchor (EraCrypto era)) -> VotingProcedure era
[vProcVote] :: VotingProcedure era -> !Vote
[vProcAnchor] :: VotingProcedure era -> !StrictMaybe (Anchor (EraCrypto era))
newtype () => VotingProcedures era
VotingProcedures :: Map (Voter (EraCrypto era)) (Map (GovActionId (EraCrypto era)) (VotingProcedure era)) -> VotingProcedures era
[unVotingProcedures] :: VotingProcedures era -> Map (Voter (EraCrypto era)) (Map (GovActionId (EraCrypto era)) (VotingProcedure era))
data () => ProposalProcedure era
ProposalProcedure :: !Coin -> !RewardAcnt (EraCrypto era) -> !GovAction era -> !Anchor (EraCrypto era) -> ProposalProcedure era
[pProcDeposit] :: ProposalProcedure era -> !Coin
[pProcReturnAddr] :: ProposalProcedure era -> !RewardAcnt (EraCrypto era)
[pProcGovAction] :: ProposalProcedure era -> !GovAction era
[pProcAnchor] :: ProposalProcedure era -> !Anchor (EraCrypto era)
data () => Constitution era
Constitution :: !Anchor (EraCrypto era) -> !StrictMaybe (ScriptHash (EraCrypto era)) -> Constitution era
[constitutionAnchor] :: Constitution era -> !Anchor (EraCrypto era)
[constitutionScript] :: Constitution era -> !StrictMaybe (ScriptHash (EraCrypto era))
constitutionAnchorL :: forall era f. Functor f => (Anchor (EraCrypto era) -> f (Anchor (EraCrypto era))) -> Constitution era -> f (Constitution era)
constitutionScriptL :: forall era f. Functor f => (StrictMaybe (ScriptHash (EraCrypto era)) -> f (StrictMaybe (ScriptHash (EraCrypto era)))) -> Constitution era -> f (Constitution era)
data () => ConwayGovState era
ConwayGovState :: !ProposalsSnapshot era -> !EnactState era -> !DRepPulsingState era -> ConwayGovState era
[cgProposals] :: ConwayGovState era -> !ProposalsSnapshot era
[cgEnactState] :: ConwayGovState era -> !EnactState era
[cgDRepPulsingState] :: ConwayGovState era -> !DRepPulsingState era
cgEnactStateL :: forall era f. Functor f => (EnactState era -> f (EnactState era)) -> ConwayGovState era -> f (ConwayGovState era)
cgProposalsL :: forall era f. Functor f => (ProposalsSnapshot era -> f (ProposalsSnapshot era)) -> ConwayGovState era -> f (ConwayGovState era)
data () => RatifyState era
RatifyState :: !EnactState era -> !Set (GovActionId (EraCrypto era)) -> !Bool -> RatifyState era
[rsEnactState] :: RatifyState era -> !EnactState era
[rsRemoved] :: RatifyState era -> !Set (GovActionId (EraCrypto era))
[rsDelayed] :: RatifyState era -> !Bool
data () => EnactState era
EnactState :: !StrictMaybe (Committee era) -> !Constitution era -> !PParams era -> !PParams era -> !Coin -> !Map (Credential 'Staking (EraCrypto era)) Coin -> !PrevGovActionIds era -> EnactState era
[ensCommittee] :: EnactState era -> !StrictMaybe (Committee era)
[ensConstitution] :: EnactState era -> !Constitution era
[ensCurPParams] :: EnactState era -> !PParams era
[ensPrevPParams] :: EnactState era -> !PParams era
[ensTreasury] :: EnactState era -> !Coin
[ensWithdrawals] :: EnactState era -> !Map (Credential 'Staking (EraCrypto era)) Coin
[ensPrevGovActionIds] :: EnactState era -> !PrevGovActionIds era
data () => Voter c
CommitteeVoter :: !Credential 'HotCommitteeRole c -> Voter c
DRepVoter :: !Credential 'DRepRole c -> Voter c
StakePoolVoter :: !KeyHash 'StakePool c -> Voter c
data () => Vote
VoteNo :: Vote
VoteYes :: Vote
Abstain :: Vote
data () => GovAction era
ParameterChange :: !StrictMaybe (PrevGovActionId 'PParamUpdatePurpose (EraCrypto era)) -> !PParamsUpdate era -> GovAction era
HardForkInitiation :: !StrictMaybe (PrevGovActionId 'HardForkPurpose (EraCrypto era)) -> !ProtVer -> GovAction era
TreasuryWithdrawals :: !Map (RewardAcnt (EraCrypto era)) Coin -> GovAction era
NoConfidence :: !StrictMaybe (PrevGovActionId 'CommitteePurpose (EraCrypto era)) -> GovAction era
UpdateCommittee :: !StrictMaybe (PrevGovActionId 'CommitteePurpose (EraCrypto era)) -> !Set (Credential 'ColdCommitteeRole (EraCrypto era)) -> !Map (Credential 'ColdCommitteeRole (EraCrypto era)) EpochNo -> !UnitInterval -> GovAction era
NewConstitution :: !StrictMaybe (PrevGovActionId 'ConstitutionPurpose (EraCrypto era)) -> !Constitution era -> GovAction era
InfoAction :: GovAction era
data () => GovActionId c
GovActionId :: !TxId c -> !GovActionIx -> GovActionId c
[gaidTxId] :: GovActionId c -> !TxId c
[gaidGovActionIx] :: GovActionId c -> !GovActionIx
newtype () => GovActionIx
GovActionIx :: Word32 -> GovActionIx
data () => GovActionState era
GovActionState :: !GovActionId (EraCrypto era) -> !Map (Credential 'HotCommitteeRole (EraCrypto era)) Vote -> !Map (Credential 'DRepRole (EraCrypto era)) Vote -> !Map (KeyHash 'StakePool (EraCrypto era)) Vote -> !Coin -> !RewardAcnt (EraCrypto era) -> !GovAction era -> !EpochNo -> !EpochNo -> GovActionState era
[gasId] :: GovActionState era -> !GovActionId (EraCrypto era)
[gasCommitteeVotes] :: GovActionState era -> !Map (Credential 'HotCommitteeRole (EraCrypto era)) Vote
[gasDRepVotes] :: GovActionState era -> !Map (Credential 'DRepRole (EraCrypto era)) Vote
[gasStakePoolVotes] :: GovActionState era -> !Map (KeyHash 'StakePool (EraCrypto era)) Vote
[gasDeposit] :: GovActionState era -> !Coin
[gasReturnAddr] :: GovActionState era -> !RewardAcnt (EraCrypto era)
[gasAction] :: GovActionState era -> !GovAction era
[gasProposedIn] :: GovActionState era -> !EpochNo
[gasExpiresAfter] :: GovActionState era -> !EpochNo
data () => GovActionPurpose
PParamUpdatePurpose :: GovActionPurpose
HardForkPurpose :: GovActionPurpose
CommitteePurpose :: GovActionPurpose
ConstitutionPurpose :: GovActionPurpose
newtype () => PrevGovActionId (r :: GovActionPurpose) c
PrevGovActionId :: GovActionId c -> PrevGovActionId (r :: GovActionPurpose) c
[unPrevGovActionId] :: PrevGovActionId (r :: GovActionPurpose) c -> GovActionId c
govActionIdToText :: GovActionId c -> Text
data () => Anchor c
Anchor :: !Url -> !SafeHash c AnchorData -> Anchor c
[anchorUrl] :: Anchor c -> !Url
[anchorDataHash] :: Anchor c -> !SafeHash c AnchorData
newtype () => AnchorData
AnchorData :: ByteString -> AnchorData
hashAnchorData :: Crypto c => AnchorData -> SafeHash c AnchorData

module Cardano.Ledger.Api.PParams
data () => PParams era
emptyPParams :: EraPParams era => PParams era
type family UpgradePParams (f :: Type -> Type) era
upgradePParams :: (EraPParams era, EraPParams (PreviousEra era)) => UpgradePParams Identity era -> PParams (PreviousEra era) -> PParams era
type family DowngradePParams (f :: Type -> Type) era
downgradePParams :: (EraPParams era, EraPParams (PreviousEra era)) => DowngradePParams Identity era -> PParams era -> PParams (PreviousEra era)
data () => PParamsUpdate era
emptyPParamsUpdate :: EraPParams era => PParamsUpdate era
upgradePParamsUpdate :: (EraPParams era, EraPParams (PreviousEra era)) => UpgradePParams StrictMaybe era -> PParamsUpdate (PreviousEra era) -> PParamsUpdate era
downgradePParamsUpdate :: (EraPParams era, EraPParams (PreviousEra era)) => DowngradePParams StrictMaybe era -> PParamsUpdate era -> PParamsUpdate (PreviousEra era)
ppMinFeeAL :: EraPParams era => Lens' (PParams era) Coin
ppuMinFeeAL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Coin)
ppMinFeeBL :: EraPParams era => Lens' (PParams era) Coin
ppuMinFeeBL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Coin)
ppMaxBBSizeL :: EraPParams era => Lens' (PParams era) Natural
ppuMaxBBSizeL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Natural)
ppMaxBHSizeL :: EraPParams era => Lens' (PParams era) Natural
ppuMaxBHSizeL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Natural)
ppPoolDepositL :: EraPParams era => Lens' (PParams era) Coin
ppuPoolDepositL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Coin)
ppEMaxL :: EraPParams era => Lens' (PParams era) EpochNo
ppuEMaxL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe EpochNo)
ppNOptL :: EraPParams era => Lens' (PParams era) Natural
ppuNOptL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Natural)
ppA0L :: EraPParams era => Lens' (PParams era) NonNegativeInterval
ppuA0L :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe NonNegativeInterval)
ppTauL :: EraPParams era => Lens' (PParams era) UnitInterval
ppuTauL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe UnitInterval)
ppRhoL :: EraPParams era => Lens' (PParams era) UnitInterval
ppuRhoL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe UnitInterval)
ppDL :: (EraPParams era, ProtVerAtMost era 6) => Lens' (PParams era) UnitInterval
ppDG :: EraPParams era => SimpleGetter (PParams era) UnitInterval
ppuDL :: (EraPParams era, ProtVerAtMost era 6) => Lens' (PParamsUpdate era) (StrictMaybe UnitInterval)
ppExtraEntropyL :: (EraPParams era, ProtVerAtMost era 6) => Lens' (PParams era) Nonce
ppuExtraEntropyL :: (EraPParams era, ProtVerAtMost era 6) => Lens' (PParamsUpdate era) (StrictMaybe Nonce)
ppProtocolVersionL :: EraPParams era => Lens' (PParams era) ProtVer
ppuProtocolVersionL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe ProtVer)
ppuMinUTxOValueL :: (EraPParams era, ProtVerAtMost era 4) => Lens' (PParamsUpdate era) (StrictMaybe Coin)
ppMinUTxOValueL :: (EraPParams era, ProtVerAtMost era 4) => Lens' (PParams era) Coin
ppMinPoolCostL :: EraPParams era => Lens' (PParams era) Coin
ppuMinPoolCostL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Coin)
ppKeyDepositL :: EraPParams era => Lens' (PParams era) Coin
ppuKeyDepositL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Coin)
ppMaxTxSizeL :: EraPParams era => Lens' (PParams era) Natural
ppuMaxTxSizeL :: EraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Natural)
data () => UpgradeAlonzoPParams (f :: Type -> Type)
UpgradeAlonzoPParams :: !HKD f CoinPerWord -> !HKD f CostModels -> !HKD f Prices -> !HKD f ExUnits -> !HKD f ExUnits -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> UpgradeAlonzoPParams (f :: Type -> Type)
[uappCoinsPerUTxOWord] :: UpgradeAlonzoPParams (f :: Type -> Type) -> !HKD f CoinPerWord
[uappCostModels] :: UpgradeAlonzoPParams (f :: Type -> Type) -> !HKD f CostModels
[uappPrices] :: UpgradeAlonzoPParams (f :: Type -> Type) -> !HKD f Prices
[uappMaxTxExUnits] :: UpgradeAlonzoPParams (f :: Type -> Type) -> !HKD f ExUnits
[uappMaxBlockExUnits] :: UpgradeAlonzoPParams (f :: Type -> Type) -> !HKD f ExUnits
[uappMaxValSize] :: UpgradeAlonzoPParams (f :: Type -> Type) -> !HKD f Natural
[uappCollateralPercentage] :: UpgradeAlonzoPParams (f :: Type -> Type) -> !HKD f Natural
[uappMaxCollateralInputs] :: UpgradeAlonzoPParams (f :: Type -> Type) -> !HKD f Natural
newtype () => DowngradeAlonzoPParams (f :: Type -> Type)
DowngradeAlonzoPParams :: HKD f Coin -> DowngradeAlonzoPParams (f :: Type -> Type)
[dappMinUTxOValue] :: DowngradeAlonzoPParams (f :: Type -> Type) -> HKD f Coin
data () => LangDepView
LangDepView :: ByteString -> ByteString -> LangDepView
[tag] :: LangDepView -> ByteString
[params] :: LangDepView -> ByteString
getLanguageView :: AlonzoEraPParams era => PParams era -> Language -> LangDepView
ppCostModelsL :: AlonzoEraPParams era => Lens' (PParams era) CostModels
ppuCostModelsL :: AlonzoEraPParams era => Lens' (PParamsUpdate era) (StrictMaybe CostModels)
ppPricesL :: AlonzoEraPParams era => Lens' (PParams era) Prices
ppuPricesL :: AlonzoEraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Prices)
ppMaxTxExUnitsL :: AlonzoEraPParams era => Lens' (PParams era) ExUnits
ppuMaxTxExUnitsL :: AlonzoEraPParams era => Lens' (PParamsUpdate era) (StrictMaybe ExUnits)
ppMaxBlockExUnitsL :: AlonzoEraPParams era => Lens' (PParams era) ExUnits
ppuMaxBlockExUnitsL :: AlonzoEraPParams era => Lens' (PParamsUpdate era) (StrictMaybe ExUnits)
ppMaxValSizeL :: AlonzoEraPParams era => Lens' (PParams era) Natural
ppuMaxValSizeL :: AlonzoEraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Natural)
newtype () => CoinPerWord
CoinPerWord :: Coin -> CoinPerWord
[unCoinPerWord] :: CoinPerWord -> Coin
ppCoinsPerUTxOWordL :: (AlonzoEraPParams era, ExactEra AlonzoEra era) => Lens' (PParams era) CoinPerWord
ppuCoinsPerUTxOWordL :: (AlonzoEraPParams era, ExactEra AlonzoEra era) => Lens' (PParamsUpdate era) (StrictMaybe CoinPerWord)
ppCollateralPercentageL :: AlonzoEraPParams era => Lens' (PParams era) Natural
ppuCollateralPercentageL :: AlonzoEraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Natural)
ppMaxCollateralInputsL :: AlonzoEraPParams era => Lens' (PParams era) Natural
ppuMaxCollateralInputsL :: AlonzoEraPParams era => Lens' (PParamsUpdate era) (StrictMaybe Natural)
data () => DowngradeBabbagePParams (f :: Type -> Type)
DowngradeBabbagePParams :: !HKD f UnitInterval -> !HKD f Nonce -> DowngradeBabbagePParams (f :: Type -> Type)
[dbppD] :: DowngradeBabbagePParams (f :: Type -> Type) -> !HKD f UnitInterval
[dbppExtraEntropy] :: DowngradeBabbagePParams (f :: Type -> Type) -> !HKD f Nonce
newtype () => CoinPerByte
CoinPerByte :: Coin -> CoinPerByte
[unCoinPerByte] :: CoinPerByte -> Coin
coinsPerUTxOWordToCoinsPerUTxOByte :: CoinPerWord -> CoinPerByte
coinsPerUTxOByteToCoinsPerUTxOWord :: CoinPerByte -> CoinPerWord
ppCoinsPerUTxOByteL :: BabbageEraPParams era => Lens' (PParams era) CoinPerByte
ppuCoinsPerUTxOByteL :: BabbageEraPParams era => Lens' (PParamsUpdate era) (StrictMaybe CoinPerByte)
class (Era era, Eq PParamsHKD Identity era, Ord PParamsHKD Identity era, Show PParamsHKD Identity era, NFData PParamsHKD Identity era, EncCBOR PParamsHKD Identity era, DecCBOR PParamsHKD Identity era, ToCBOR PParamsHKD Identity era, FromCBOR PParamsHKD Identity era, NoThunks PParamsHKD Identity era, ToJSON PParamsHKD Identity era, ToExpr PParamsHKD Identity era, Eq PParamsHKD StrictMaybe era, Ord PParamsHKD StrictMaybe era, Show PParamsHKD StrictMaybe era, NFData PParamsHKD StrictMaybe era, EncCBOR PParamsHKD StrictMaybe era, DecCBOR PParamsHKD StrictMaybe era, ToCBOR PParamsHKD StrictMaybe era, FromCBOR PParamsHKD StrictMaybe era, NoThunks PParamsHKD StrictMaybe era, ToJSON PParamsHKD StrictMaybe era, ToExpr PParamsHKD StrictMaybe era) => EraPParams era
class EraPParams era => AlonzoEraPParams era
class AlonzoEraPParams era => BabbageEraPParams era

module Cardano.Ledger.Api.Scripts.Data
data () => Data era
pattern Data :: Era era => Data -> Data era
getPlutusData :: Data era -> Data
type DataHash c = SafeHash c EraIndependentData
hashData :: Era era => Data era -> DataHash (EraCrypto era)
data () => Datum era
NoDatum :: Datum era
DatumHash :: !DataHash (EraCrypto era) -> Datum era
Datum :: !BinaryData era -> Datum era
datumDataHash :: Era era => Datum era -> StrictMaybe (DataHash (EraCrypto era))
data () => BinaryData era
makeBinaryData :: Era era => ShortByteString -> Either String (BinaryData era)
hashBinaryData :: Era era => BinaryData era -> DataHash (EraCrypto era)
binaryDataToData :: Era era => BinaryData era -> Data era
dataToBinaryData :: Era era => Data era -> BinaryData era

module Cardano.Ledger.Api.Scripts
class (Era era, Show Script era, Eq Script era, EqRaw Script era, ToCBOR Script era, EncCBOR Script era, DecCBOR Annotator Script era, NoThunks Script era, SafeToHash Script era, ToExpr Script era) => EraScript era where {
    type family Script era = (r :: Type) | r -> era;
    type family NativeScript era = (r :: Type) | r -> era;
}
scriptPrefixTag :: EraScript era => Script era -> ByteString
upgradeScript :: EraScript era => Script (PreviousEra era) -> Script era
hashScript :: EraScript era => Script era -> ScriptHash (EraCrypto era)
getNativeScript :: EraScript era => Script era -> Maybe (NativeScript era)
validateNativeScript :: EraTx era => Tx era -> NativeScript era -> Bool
isNativeScript :: EraScript era => Script era -> Bool
isPlutusScript :: EraScript era => Script era -> Bool
data () => ScriptHash c
data () => CostModels
CostModels :: !Map Language CostModel -> !Map Language CostModelError -> !Map Word8 [Integer] -> CostModels
[costModelsValid] :: CostModels -> !Map Language CostModel
[costModelsErrors] :: CostModels -> !Map Language CostModelError
[costModelsUnknown] :: CostModels -> !Map Word8 [Integer]
data () => ValidityInterval
ValidityInterval :: !StrictMaybe SlotNo -> !StrictMaybe SlotNo -> ValidityInterval
[invalidBefore] :: ValidityInterval -> !StrictMaybe SlotNo
[invalidHereafter] :: ValidityInterval -> !StrictMaybe SlotNo

module Cardano.Ledger.Api.State.Query

-- | Filter out stake pool delegations and rewards for a set of stake
--   credentials
filterStakePoolDelegsAndRewards :: UMap c -> Set (Credential 'Staking c) -> (Map (Credential 'Staking c) (KeyHash 'StakePool c), Map (Credential 'Staking c) Coin)

-- | Uses <a>filterStakePoolDelegsAndRewards</a> to get the same
--   information from the <a>NewEpochState</a>
--   
--   Implementation for <tt>GetFilteredDelegationsAndRewardAccounts</tt>
--   query.
queryStakePoolDelegsAndRewards :: NewEpochState era -> Set (Credential 'Staking (EraCrypto era)) -> (Map (Credential 'Staking (EraCrypto era)) (KeyHash 'StakePool (EraCrypto era)), Map (Credential 'Staking (EraCrypto era)) Coin)

-- | This query returns all of the state related to governance
queryGovState :: NewEpochState era -> GovState era
queryConstitution :: EraGov era => NewEpochState era -> Maybe (Constitution era)
queryConstitutionHash :: EraGov era => NewEpochState era -> Maybe (SafeHash (EraCrypto era) AnchorData)

-- | Query DRep state.
queryDRepState :: NewEpochState era -> Set (Credential 'DRepRole (EraCrypto era)) -> Map (Credential 'DRepRole (EraCrypto era)) (DRepState (EraCrypto era))

-- | Query DRep stake distribution. Note that this can be an expensive
--   query because there is a chance that current distribution has not been
--   fully computed yet.
queryDRepStakeDistr :: EraGov era => NewEpochState era -> Set (DRep (EraCrypto era)) -> Map (DRep (EraCrypto era)) Coin

-- | Query committee members

-- | <i>Deprecated: In favor of <a>queryCommitteeMembersState</a></i>
queryCommitteeState :: NewEpochState era -> CommitteeState era

-- | Query committee members. Whenever the system is in No Confidence mode
--   this query will return <a>Nothing</a>.
queryCommitteeMembersState :: forall era. EraGov era => Set (Credential 'ColdCommitteeRole (EraCrypto era)) -> Set (Credential 'HotCommitteeRole (EraCrypto era)) -> Set MemberStatus -> NewEpochState era -> Maybe (CommitteeMembersState (EraCrypto era))
data CommitteeMemberState c
CommitteeMemberState :: !HotCredAuthStatus c -> !MemberStatus -> !Maybe EpochNo -> !NextEpochChange -> CommitteeMemberState c
[cmsHotCredAuthStatus] :: CommitteeMemberState c -> !HotCredAuthStatus c
[cmsStatus] :: CommitteeMemberState c -> !MemberStatus

-- | Absolute epoch number when the member expires
[cmsExpiration] :: CommitteeMemberState c -> !Maybe EpochNo

-- | Changes to the member at the next epoch
[cmsNextEpochChange] :: CommitteeMemberState c -> !NextEpochChange
data CommitteeMembersState c
CommitteeMembersState :: !Map (Credential 'ColdCommitteeRole c) (CommitteeMemberState c) -> !UnitInterval -> !EpochNo -> CommitteeMembersState c
[csCommittee] :: CommitteeMembersState c -> !Map (Credential 'ColdCommitteeRole c) (CommitteeMemberState c)
[csQuorum] :: CommitteeMembersState c -> !UnitInterval

-- | Current epoch number. This is necessary to interpret committee member
--   states
[csEpochNo] :: CommitteeMembersState c -> !EpochNo
data HotCredAuthStatus c
MemberAuthorized :: Credential 'HotCommitteeRole c -> HotCredAuthStatus c

-- | Member enacted, but no hot credential for voting has been registered
MemberNotAuthorized :: HotCredAuthStatus c
MemberResigned :: HotCredAuthStatus c
data MemberStatus
Active :: MemberStatus
Expired :: MemberStatus

-- | This can happen when a hot credential for an unknown cold credential
--   exists. Such Committee member will be either removed from the state at
--   the next epoch boundary or enacted as a new member.
Unrecognized :: MemberStatus
data NextEpochChange
ToBeEnacted :: NextEpochChange

-- | Member will be removed
ToBeRemoved :: NextEpochChange
NoChangeExpected :: NextEpochChange


-- | This module is used for defining initial configuration for all. It is
--   also used in testing and benchmarking to initilize a chain in a
--   particular era without going through the trouble of generating all the
--   history for preceeding eras.
module Cardano.Ledger.Api.Transition
class (EraTxOut era, EraGov era, ToJSON TransitionConfig era, FromJSON TransitionConfig era, Default StashedAVVMAddresses era) => EraTransition era
data family TransitionConfig era
mkLatestTransitionConfig :: Crypto c => ShelleyGenesis c -> AlonzoGenesis -> ConwayGenesis c -> TransitionConfig (LatestKnownEra c)
mkTransitionConfig :: EraTransition era => TranslationContext era -> TransitionConfig (PreviousEra era) -> TransitionConfig era
mkShelleyTransitionConfig :: ShelleyGenesis c -> TransitionConfig (ShelleyEra c)
tcShelleyGenesisL :: EraTransition era => Lens' (TransitionConfig era) (ShelleyGenesis (EraCrypto era))
tcPreviousEraConfigL :: EraTransition era => Lens' (TransitionConfig era) (TransitionConfig (PreviousEra era))
tcTranslationContextL :: EraTransition era => Lens' (TransitionConfig era) (TranslationContext era)
data () => ShelleyGenesis c
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTimeMicro -> !Word64 -> !Word64 -> !PParams (ShelleyEra c) -> !Map (KeyHash 'Genesis c) (GenDelegPair c) -> ListMap (Addr c) Coin -> ShelleyGenesisStaking c -> ShelleyGenesis c
[sgSystemStart] :: ShelleyGenesis c -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis c -> !Word32
[sgNetworkId] :: ShelleyGenesis c -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis c -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis c -> !Word64
[sgEpochLength] :: ShelleyGenesis c -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis c -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis c -> !Word64
[sgSlotLength] :: ShelleyGenesis c -> !NominalDiffTimeMicro
[sgUpdateQuorum] :: ShelleyGenesis c -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis c -> !Word64
[sgProtocolParams] :: ShelleyGenesis c -> !PParams (ShelleyEra c)
[sgGenDelegs] :: ShelleyGenesis c -> !Map (KeyHash 'Genesis c) (GenDelegPair c)
[sgInitialFunds] :: ShelleyGenesis c -> ListMap (Addr c) Coin
[sgStaking] :: ShelleyGenesis c -> ShelleyGenesisStaking c
newtype () => AlonzoGenesis
AlonzoGenesisWrapper :: UpgradeAlonzoPParams Identity -> AlonzoGenesis
[unAlonzoGenesisWrapper] :: AlonzoGenesis -> UpgradeAlonzoPParams Identity
pattern AlonzoGenesis :: CoinPerWord -> CostModels -> Prices -> ExUnits -> ExUnits -> Natural -> Natural -> Natural -> AlonzoGenesis
data () => ConwayGenesis c
ConwayGenesis :: !UpgradeConwayPParams Identity -> !Constitution (ConwayEra c) -> !Committee (ConwayEra c) -> ConwayGenesis c
[cgUpgradePParams] :: ConwayGenesis c -> !UpgradeConwayPParams Identity
[cgConstitution] :: ConwayGenesis c -> !Constitution (ConwayEra c)
[cgCommittee] :: ConwayGenesis c -> !Committee (ConwayEra c)
tcInitialPParamsG :: EraTransition era => SimpleGetter (TransitionConfig era) (PParams era)
tcInitialFundsL :: (HasCallStack, EraTransition era) => Lens' (TransitionConfig era) (ListMap (Addr (EraCrypto era)) Coin)
tcInitialStakingL :: (HasCallStack, EraTransition era) => Lens' (TransitionConfig era) (ShelleyGenesisStaking (EraCrypto era))
createInitialState :: (EraTransition era, HasCallStack) => TransitionConfig era -> NewEpochState era
registerInitialFunds :: (EraTransition era, HasCallStack) => TransitionConfig era -> NewEpochState era -> NewEpochState era
registerInitialStaking :: (EraTransition era, HasCallStack) => TransitionConfig era -> NewEpochState era -> NewEpochState era

module Cardano.Ledger.Api.Tx.Address
data () => Addr c
Addr :: Network -> PaymentCredential c -> StakeReference c -> Addr c
AddrBootstrap :: BootstrapAddress c -> Addr c
newtype () => BootstrapAddress c
BootstrapAddress :: Address -> BootstrapAddress c
[unBootstrapAddress] :: BootstrapAddress c -> Address
serialiseAddr :: Addr c -> ByteString
decodeAddr :: (Crypto c, MonadFail m) => ByteString -> m (Addr c)
decodeAddrEither :: Crypto c => ByteString -> Either String (Addr c)
decodeAddrShort :: (Crypto c, MonadFail m) => ShortByteString -> m (Addr c)
decodeAddrShortEither :: Crypto c => ShortByteString -> Either String (Addr c)
getNetwork :: Addr c -> Network
data () => RewardAcnt c
RewardAcnt :: !Network -> !Credential 'Staking c -> RewardAcnt c
[getRwdNetwork] :: RewardAcnt c -> !Network
[getRwdCred] :: RewardAcnt c -> !Credential 'Staking c
mkRwdAcnt :: Network -> Credential 'Staking c -> RewardAcnt c
serialiseRewardAcnt :: RewardAcnt c -> ByteString
deserialiseRewardAcnt :: Crypto c => ByteString -> Maybe (RewardAcnt c)

module Cardano.Ledger.Api.Tx.AuxData
class (Era era, Eq TxAuxData era, EqRaw TxAuxData era, Show TxAuxData era, NoThunks TxAuxData era, ToCBOR TxAuxData era, EncCBOR TxAuxData era, DecCBOR Annotator TxAuxData era, ToExpr TxAuxData era, HashAnnotated TxAuxData era EraIndependentTxAuxData EraCrypto era) => EraTxAuxData era where {
    type family TxAuxData era = (r :: Type) | r -> era;
}
upgradeTxAuxData :: EraTxAuxData era => TxAuxData (PreviousEra era) -> TxAuxData era
hashTxAuxData :: EraTxAuxData era => TxAuxData era -> AuxiliaryDataHash (EraCrypto era)
validateTxAuxData :: EraTxAuxData era => ProtVer -> TxAuxData era -> Bool
data () => ShelleyTxAuxData era
pattern ShelleyTxAuxData :: Era era => Map Word64 Metadatum -> ShelleyTxAuxData era
data () => Metadatum
Map :: ![(Metadatum, Metadatum)] -> Metadatum
List :: ![Metadatum] -> Metadatum
I :: !Integer -> Metadatum
B :: !ByteString -> Metadatum
S :: !Text -> Metadatum
data () => AllegraTxAuxData era
pattern AllegraTxAuxData :: Era era => Map Word64 Metadatum -> StrictSeq (Timelock era) -> AllegraTxAuxData era
data () => AlonzoTxAuxData era
pattern AlonzoTxAuxData :: Era era => Map Word64 Metadatum -> StrictSeq (Timelock era) -> Map Language (NonEmpty BinaryPlutus) -> AlonzoTxAuxData era
mkAlonzoTxAuxData :: (Foldable f, Era era) => Map Word64 Metadatum -> f (AlonzoScript era) -> AlonzoTxAuxData era
getAlonzoTxAuxDataScripts :: Era era => AlonzoTxAuxData era -> StrictSeq (AlonzoScript era)

module Cardano.Ledger.Api.Tx.Cert
class (Era era, DecCBOR TxCert era, EncCBOR TxCert era, ToCBOR TxCert era, FromCBOR TxCert era, NoThunks TxCert era, NFData TxCert era, Show TxCert era, Eq TxCert era, ToExpr TxCert era) => EraTxCert era where {
    type family TxCert era = (r :: Type) | r -> era;
    type family TxCertUpgradeError era;
    type TxCertUpgradeError era = Void;
}
upgradeTxCert :: EraTxCert era => TxCert (PreviousEra era) -> Either (TxCertUpgradeError era) (TxCert era)
getVKeyWitnessTxCert :: EraTxCert era => TxCert era -> Maybe (KeyHash 'Witness (EraCrypto era))
getScriptWitnessTxCert :: EraTxCert era => TxCert era -> Maybe (ScriptHash (EraCrypto era))
pattern RegPoolTxCert :: EraTxCert era => PoolParams (EraCrypto era) -> TxCert era
pattern RetirePoolTxCert :: EraTxCert era => KeyHash 'StakePool (EraCrypto era) -> EpochNo -> TxCert era
lookupRegStakeTxCert :: EraTxCert era => TxCert era -> Maybe (Credential 'Staking (EraCrypto era))
lookupUnRegStakeTxCert :: EraTxCert era => TxCert era -> Maybe (Credential 'Staking (EraCrypto era))
isRegStakeTxCert :: EraTxCert era => TxCert era -> Bool
isUnRegStakeTxCert :: EraTxCert era => TxCert era -> Bool
class EraTxCert era => ShelleyEraTxCert era
pattern MirTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => MIRCert (EraCrypto era) -> TxCert era
pattern GenesisDelegTxCert :: (ShelleyEraTxCert era, ProtVerAtMost era 8) => KeyHash 'Genesis (EraCrypto era) -> KeyHash 'GenesisDelegate (EraCrypto era) -> Hash (EraCrypto era) (VerKeyVRF (EraCrypto era)) -> TxCert era
pattern RegTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> TxCert era
pattern UnRegTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> TxCert era
pattern DelegStakeTxCert :: ShelleyEraTxCert era => StakeCredential (EraCrypto era) -> KeyHash 'StakePool (EraCrypto era) -> TxCert era
class ShelleyEraTxCert era => ConwayEraTxCert era
getDelegateeTxCert :: ConwayEraTxCert era => TxCert era -> Maybe (Delegatee (EraCrypto era))
data () => Delegatee c
DelegStake :: !KeyHash 'StakePool c -> Delegatee c
DelegVote :: !DRep c -> Delegatee c
DelegStakeVote :: !KeyHash 'StakePool c -> !DRep c -> Delegatee c
getStakePoolDelegatee :: Delegatee c -> Maybe (KeyHash 'StakePool c)
pattern RegDepositTxCert :: ConwayEraTxCert era => StakeCredential (EraCrypto era) -> Coin -> TxCert era
pattern UnRegDepositTxCert :: ConwayEraTxCert era => StakeCredential (EraCrypto era) -> Coin -> TxCert era
pattern DelegTxCert :: ConwayEraTxCert era => StakeCredential (EraCrypto era) -> Delegatee (EraCrypto era) -> TxCert era
pattern RegDepositDelegTxCert :: ConwayEraTxCert era => StakeCredential (EraCrypto era) -> Delegatee (EraCrypto era) -> Coin -> TxCert era
pattern AuthCommitteeHotKeyTxCert :: ConwayEraTxCert era => Credential 'ColdCommitteeRole (EraCrypto era) -> Credential 'HotCommitteeRole (EraCrypto era) -> TxCert era
pattern ResignCommitteeColdTxCert :: ConwayEraTxCert era => Credential 'ColdCommitteeRole (EraCrypto era) -> StrictMaybe (Anchor (EraCrypto era)) -> TxCert era
pattern RegDRepTxCert :: ConwayEraTxCert era => Credential 'DRepRole (EraCrypto era) -> Coin -> StrictMaybe (Anchor (EraCrypto era)) -> TxCert era
pattern UnRegDRepTxCert :: ConwayEraTxCert era => Credential 'DRepRole (EraCrypto era) -> Coin -> TxCert era

module Cardano.Ledger.Api.Tx.In
data () => TxIn c
TxIn :: !TxId c -> {-# UNPACK #-} !TxIx -> TxIn c
newtype () => TxId c
TxId :: SafeHash c EraIndependentTxBody -> TxId c
[unTxId] :: TxId c -> SafeHash c EraIndependentTxBody
mkTxInPartial :: HasCallStack => TxId c -> Integer -> TxIn c
data () => TxIx
mkTxIx :: Word16 -> TxIx
txIxToInt :: TxIx -> Int
txIxFromIntegral :: Integral a => a -> Maybe TxIx
mkTxIxPartial :: HasCallStack => Integer -> TxIx


-- | This module is used for building and inspecting transaction outputs.
--   
--   You'll find some examples below.
--   
--   Let's start by defining the GHC extensions and imports.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Cardano.Ledger.Api.Era (Babbage)
--   
--   &gt;&gt;&gt; import Lens.Micro
--   
--   &gt;&gt;&gt; import Test.Cardano.Ledger.Babbage.Serialisation.Generators () -- Neded for doctests only
--   
--   &gt;&gt;&gt; import Test.QuickCheck -- Needed for doctests only
--   </pre>
--   
--   Here's an example on how to build a very basic Babbage era transaction
--   output with a random address and value, and without any datum or
--   reference script.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   quickCheck $ \addr val -&gt;
--       let
--           -- Defining a Babbage era transaction output with some random address and value.
--           txOut = mkBasicTxOut @Babbage addr val
--        in
--           -- We verify that the transaction output contains our random address and value.
--           txOut ^. addrTxOutL == addr &amp;&amp; txOut ^. valueTxOutL == val
--   :}
--   +++ OK, passed 100 tests.
--   </pre>
module Cardano.Ledger.Api.Tx.Out
class (Val Value era, ToJSON TxOut era, DecCBOR Value era, DecCBOR CompactForm Value era, EncCBOR Value era, ToCBOR TxOut era, FromCBOR TxOut era, EncCBOR TxOut era, DecCBOR TxOut era, DecShareCBOR TxOut era, Share TxOut era ~ Interns Credential 'Staking EraCrypto era, NoThunks TxOut era, NFData TxOut era, Show TxOut era, Eq TxOut era, EraPParams era) => EraTxOut era where {
    type family TxOut era = (r :: Type) | r -> era;
}
mkBasicTxOut :: EraTxOut era => Addr (EraCrypto era) -> Value era -> TxOut era
upgradeTxOut :: EraTxOut era => TxOut (PreviousEra era) -> TxOut era
valueTxOutL :: EraTxOut era => Lens' (TxOut era) (Value era)
coinTxOutL :: (HasCallStack, EraTxOut era) => Lens' (TxOut era) Coin
isAdaOnlyTxOutF :: EraTxOut era => SimpleGetter (TxOut era) Bool
addrTxOutL :: EraTxOut era => Lens' (TxOut era) (Addr (EraCrypto era))
bootAddrTxOutF :: EraTxOut era => SimpleGetter (TxOut era) (Maybe (BootstrapAddress (EraCrypto era)))
getMinCoinTxOut :: EraTxOut era => PParams era -> TxOut era -> Coin

-- | Same as <a>setMinCoinSizedTxOut</a>, except it doesn't require the
--   size of the TxOut and will recompute it if needed. Initial amount is
--   not important.
setMinCoinTxOut :: EraTxOut era => PParams era -> TxOut era -> TxOut era
getMinCoinSizedTxOut :: EraTxOut era => PParams era -> Sized (TxOut era) -> Coin

-- | This function will adjust the output's <a>Coin</a> value to the
--   smallest amount allowed by the UTXO rule. Initial amount is not
--   important.
setMinCoinSizedTxOut :: forall era. EraTxOut era => PParams era -> Sized (TxOut era) -> Sized (TxOut era)

-- | Similar to <a>setMinCoinTxOut</a> it will guarantee that the minimum
--   requirement for the output amount is satisified, however it makes it
--   possible to set a higher amount than the minimaly required.
--   
--   <pre>
--   &gt; ensureMinCoinTxOut pp (txOut &amp; coinTxOutL .~ zero) == setMinCoinTxOut pp (txOut &amp; coinTxOutL .~ zero)
--   &gt; (ensureMinCoinTxOut pp txOut ^. coinTxOutL) &gt;= (setMinCoinTxOut pp txOut ^. coinTxOutL)
--   </pre>
ensureMinCoinTxOut :: EraTxOut era => PParams era -> TxOut era -> TxOut era

-- | Similar to <a>setMinCoinSizedTxOut</a> it will guarantee that the
--   minimum requirement for the output amount is satisified, however it
--   makes it possible to set a higher amount than the minimaly required.
--   
--   <a>ensureMinCoinSizedTxOut</a> relates to <a>setMinCoinSizedTxOut</a>
--   in the same way that <a>ensureMinCoinTxOut</a> relates to
--   <a>setMinCoinTxOut</a>.
ensureMinCoinSizedTxOut :: forall era. EraTxOut era => PParams era -> Sized (TxOut era) -> Sized (TxOut era)
class (AlonzoEraPParams era, EraTxOut era) => AlonzoEraTxOut era
dataHashTxOutL :: AlonzoEraTxOut era => Lens' (TxOut era) (StrictMaybe (DataHash (EraCrypto era)))
type DataHash c = SafeHash c EraIndependentData
datumTxOutF :: AlonzoEraTxOut era => SimpleGetter (TxOut era) (Datum era)
class (AlonzoEraTxOut era, EraScript era) => BabbageEraTxOut era
dataTxOutL :: BabbageEraTxOut era => Lens' (TxOut era) (StrictMaybe (Data era))
data () => Data era
pattern Data :: Era era => Data -> Data era
datumTxOutL :: BabbageEraTxOut era => Lens' (TxOut era) (Datum era)
data () => Datum era
NoDatum :: Datum era
DatumHash :: !DataHash (EraCrypto era) -> Datum era
Datum :: !BinaryData era -> Datum era
referenceScriptTxOutL :: BabbageEraTxOut era => Lens' (TxOut era) (StrictMaybe (Script era))

module Cardano.Ledger.Api.Tx.Body
class (EraTxOut era, EraTxCert era, EraPParams era, HashAnnotated TxBody era EraIndependentTxBody EraCrypto era, DecCBOR Annotator TxBody era, EncCBOR TxBody era, ToCBOR TxBody era, NoThunks TxBody era, NFData TxBody era, Show TxBody era, Eq TxBody era, EqRaw TxBody era, ToExpr TxBody era) => EraTxBody era where {
    type family TxBody era = (r :: Type) | r -> era;
    type TxBodyUpgradeError era = Void;
}
mkBasicTxBody :: EraTxBody era => TxBody era
inputsTxBodyL :: EraTxBody era => Lens' (TxBody era) (Set (TxIn (EraCrypto era)))
outputsTxBodyL :: EraTxBody era => Lens' (TxBody era) (StrictSeq (TxOut era))
feeTxBodyL :: EraTxBody era => Lens' (TxBody era) Coin
withdrawalsTxBodyL :: EraTxBody era => Lens' (TxBody era) (Withdrawals (EraCrypto era))
newtype () => Withdrawals c
Withdrawals :: Map (RewardAcnt c) Coin -> Withdrawals c
[unWithdrawals] :: Withdrawals c -> Map (RewardAcnt c) Coin
auxDataHashTxBodyL :: EraTxBody era => Lens' (TxBody era) (StrictMaybe (AuxiliaryDataHash (EraCrypto era)))
data () => AuxiliaryDataHash c
spendableInputsTxBodyF :: EraTxBody era => SimpleGetter (TxBody era) (Set (TxIn (EraCrypto era)))
allInputsTxBodyF :: EraTxBody era => SimpleGetter (TxBody era) (Set (TxIn (EraCrypto era)))

-- | Evaluate the difference between the value currently being consumed by
--   a transaction and the total value being produced. This value will be
--   zero for a valid transaction.
--   
--   In case when full <a>CertState</a> is available then this can be
--   simplified to:
--   
--   <pre>
--   let lookupRefund = lookupDepositDState (certDState dpState)
--   let isRegPoolId = (`Map.member` psStakePoolParams (certPState dpState))
--   evalBalanceTxBody pp lookupRefund isRegPoolId utxo txBody
--   </pre>
evalBalanceTxBody :: EraUTxO era => PParams era -> (Credential 'Staking (EraCrypto era) -> Maybe Coin) -> (Credential 'DRepRole (EraCrypto era) -> Maybe Coin) -> (KeyHash 'StakePool (EraCrypto era) -> Bool) -> UTxO era -> TxBody era -> Value era
class (ShelleyEraTxCert era, EraTxBody era) => ShelleyEraTxBody era
ttlTxBodyL :: ShelleyEraTxBody era => Lens' (TxBody era) SlotNo
updateTxBodyL :: ShelleyEraTxBody era => Lens' (TxBody era) (StrictMaybe (Update era))
updateTxBodyG :: ShelleyEraTxBody era => SimpleGetter (TxBody era) (StrictMaybe (Update era))
certsTxBodyL :: EraTxBody era => Lens' (TxBody era) (StrictSeq (TxCert era))
class ShelleyEraTxBody era => AllegraEraTxBody era
vldtTxBodyL :: AllegraEraTxBody era => Lens' (TxBody era) ValidityInterval
data () => ValidityInterval
ValidityInterval :: !StrictMaybe SlotNo -> !StrictMaybe SlotNo -> ValidityInterval
[invalidBefore] :: ValidityInterval -> !StrictMaybe SlotNo
[invalidHereafter] :: ValidityInterval -> !StrictMaybe SlotNo

-- | Lens to access the <a>invalidBefore</a> field of a
--   <a>ValidityInterval</a> as a 'Maybe SlotNo'.
invalidBeforeL :: Lens' ValidityInterval (Maybe SlotNo)

-- | Lens to access the <tt>invalidHereAfter</tt> field of a
--   <a>ValidityInterval</a> as a 'Maybe SlotNo'.
invalidHereAfterL :: Lens' ValidityInterval (Maybe SlotNo)
class AllegraEraTxBody era => MaryEraTxBody era
mintTxBodyL :: MaryEraTxBody era => Lens' (TxBody era) (MultiAsset (EraCrypto era))
mintValueTxBodyF :: MaryEraTxBody era => SimpleGetter (TxBody era) (Value era)
mintedTxBodyF :: MaryEraTxBody era => SimpleGetter (TxBody era) (Set (ScriptHash (EraCrypto era)))
class (MaryEraTxBody era, AlonzoEraTxOut era) => AlonzoEraTxBody era
collateralInputsTxBodyL :: AlonzoEraTxBody era => Lens' (TxBody era) (Set (TxIn (EraCrypto era)))
reqSignerHashesTxBodyL :: AlonzoEraTxBody era => Lens' (TxBody era) (Set (KeyHash 'Witness (EraCrypto era)))
scriptIntegrityHashTxBodyL :: AlonzoEraTxBody era => Lens' (TxBody era) (StrictMaybe (ScriptIntegrityHash (EraCrypto era)))
networkIdTxBodyL :: AlonzoEraTxBody era => Lens' (TxBody era) (StrictMaybe Network)
class (AlonzoEraTxBody era, BabbageEraTxOut era) => BabbageEraTxBody era
sizedOutputsTxBodyL :: BabbageEraTxBody era => Lens' (TxBody era) (StrictSeq (Sized (TxOut era)))
referenceInputsTxBodyL :: BabbageEraTxBody era => Lens' (TxBody era) (Set (TxIn (EraCrypto era)))
totalCollateralTxBodyL :: BabbageEraTxBody era => Lens' (TxBody era) (StrictMaybe Coin)
collateralReturnTxBodyL :: BabbageEraTxBody era => Lens' (TxBody era) (StrictMaybe (TxOut era))
sizedCollateralReturnTxBodyL :: BabbageEraTxBody era => Lens' (TxBody era) (StrictMaybe (Sized (TxOut era)))
allSizedOutputsTxBodyF :: BabbageEraTxBody era => SimpleGetter (TxBody era) (StrictSeq (Sized (TxOut era)))
class (BabbageEraTxBody era, ConwayEraTxCert era) => ConwayEraTxBody era
votingProceduresTxBodyL :: ConwayEraTxBody era => Lens' (TxBody era) (VotingProcedures era)
proposalProceduresTxBodyL :: ConwayEraTxBody era => Lens' (TxBody era) (OSet (ProposalProcedure era))

module Cardano.Ledger.Api.Tx.Wits
class (EraScript era, Eq TxWits era, EqRaw TxWits era, Show TxWits era, Monoid TxWits era, NoThunks TxWits era, ToCBOR TxWits era, EncCBOR TxWits era, DecCBOR Annotator TxWits era, ToExpr TxWits era) => EraTxWits era where {
    type family TxWits era = (r :: Type) | r -> era;
}
mkBasicTxWits :: EraTxWits era => TxWits era
addrTxWitsL :: EraTxWits era => Lens' (TxWits era) (Set (WitVKey 'Witness (EraCrypto era)))
data () => KeyRole
Witness :: KeyRole
data () => WitVKey (kr :: KeyRole) c
pattern WitVKey :: (Typeable kr, Crypto c) => VKey kr c -> SignedDSIGN c (Hash c EraIndependentTxBody) -> WitVKey kr c
witVKeyBytes :: forall (kr :: KeyRole) c. WitVKey kr c -> ByteString
witVKeyHash :: forall (kr :: KeyRole) c. WitVKey kr c -> KeyHash 'Witness c
bootAddrTxWitsL :: EraTxWits era => Lens' (TxWits era) (Set (BootstrapWitness (EraCrypto era)))
data () => BootstrapWitness c
scriptTxWitsL :: EraTxWits era => Lens' (TxWits era) (Map (ScriptHash (EraCrypto era)) (Script era))
hashScriptTxWitsL :: EraTxWits era => Lens (TxWits era) (TxWits era) (Map (ScriptHash (EraCrypto era)) (Script era)) [Script era]
class EraTxWits era => AlonzoEraTxWits era
datsTxWitsL :: AlonzoEraTxWits era => Lens' (TxWits era) (TxDats era)
hashDataTxWitsL :: AlonzoEraTxWits era => Lens (TxWits era) (TxWits era) (TxDats era) [Data era]
data () => TxDats era
pattern TxDats :: Era era => Map (DataHash (EraCrypto era)) (Data era) -> TxDats era
pattern TxDats' :: Map (DataHash (EraCrypto era)) (Data era) -> TxDats era
unTxDats :: TxDats era -> Map (DataHash (EraCrypto era)) (Data era)
rdmrsTxWitsL :: AlonzoEraTxWits era => Lens' (TxWits era) (Redeemers era)
data () => Redeemers era
pattern Redeemers :: Era era => Map RdmrPtr (Data era, ExUnits) -> Redeemers era
unRedeemers :: Era era => Redeemers era -> Map RdmrPtr (Data era, ExUnits)
data () => RdmrPtr
RdmrPtr :: !Tag -> {-# UNPACK #-} !Word64 -> RdmrPtr
data () => Tag
Spend :: Tag
Mint :: Tag
Cert :: Tag
Rewrd :: Tag


-- | Transaction building and inspecting relies heavily on lenses
--   (<tt>microlens</tt>). Therefore, some familiarity with those is
--   necessary. However, you can probably go a long way by simply looking
--   at the examples and try to go from there.
--   
--   Let's start by defining the GHC extensions and imports.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XScopedTypeVariables
--   
--   &gt;&gt;&gt; import Test.QuickCheck
--   
--   &gt;&gt;&gt; import qualified Data.Sequence.Strict as StrictSeq
--   
--   &gt;&gt;&gt; import Cardano.Ledger.Api.Era (Babbage)
--   
--   &gt;&gt;&gt; import Lens.Micro
--   
--   &gt;&gt;&gt; import Test.Cardano.Ledger.Babbage.Arbitrary ()
--   </pre>
--   
--   Here's an example on how to build a Babbage era unbalanced transaction
--   containing a single transaction output using the provided interface.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   quickCheck $ \(txOut :: TxOut Babbage) -&gt;
--       let
--           -- Defining a Babbage era transaction body with a single random transaction output
--           txBody = mkBasicTxBody
--                  &amp; outputsTxBodyL &lt;&gt;~ StrictSeq.singleton txOut
--           -- Defining a basic transaction with our transaction body
--           tx = mkBasicTx txBody
--        in
--           -- We verify that the transaction's outputs contains our single random output
--           tx ^. bodyTxL . outputsTxBodyL == StrictSeq.singleton txOut
--   :}
--   +++ OK, passed 100 tests.
--   </pre>
module Cardano.Ledger.Api.Tx
class (EraTxBody era, EraTxWits era, EraTxAuxData era, EraPParams era, NoThunks Tx era, DecCBOR Annotator Tx era, EncCBOR Tx era, ToCBOR Tx era, Show Tx era, Eq Tx era, EqRaw Tx era, ToExpr Tx era) => EraTx era where {
    type family Tx era = (r :: Type) | r -> era;
    type TxUpgradeError era = Void;
}
mkBasicTx :: EraTx era => TxBody era -> Tx era
bodyTxL :: EraTx era => Lens' (Tx era) (TxBody era)
witsTxL :: EraTx era => Lens' (Tx era) (TxWits era)
auxDataTxL :: EraTx era => Lens' (Tx era) (StrictMaybe (AuxiliaryData era))
sizeTxF :: EraTx era => SimpleGetter (Tx era) Integer
getMinFeeTx :: EraTx era => PParams era -> Tx era -> Coin
setMinFeeTx :: EraTx era => PParams era -> Tx era -> Tx era
class (EraTx era, AlonzoEraTxBody era, AlonzoEraTxWits era) => AlonzoEraTx era
isValidTxL :: AlonzoEraTx era => Lens' (Tx era) IsValid
newtype () => IsValid
IsValid :: Bool -> IsValid

-- | Evaluate the execution budgets needed for all the redeemers in a given
--   transaction. If a redeemer is invalid, a failure is returned instead.
--   
--   The execution budgets in the supplied transaction are completely
--   ignored. The results of <a>evalTxExUnitsWithLogs</a> are intended to
--   replace them.
evalTxExUnits :: forall era. (AlonzoEraTx era, ExtendedUTxO era, EraUTxO era, ScriptsNeeded era ~ AlonzoScriptsNeeded era, Script era ~ AlonzoScript era, EraPlutusContext 'PlutusV1 era) => PParams era -> Tx era -> UTxO era -> EpochInfo (Either Text) -> SystemStart -> Either (TranslationError (EraCrypto era)) (RedeemerReport era)

-- | Evaluate the execution budgets needed for all the redeemers in a given
--   transaction. If a redeemer is invalid, a failure is returned instead.
--   
--   The execution budgets in the supplied transaction are completely
--   ignored. The results of <a>evaluateTransactionExecutionUnits</a> are
--   intended to replace them.

-- | <i>Deprecated: In favor of <a>evalTxExUnits</a></i>
evaluateTransactionExecutionUnits :: forall era. (AlonzoEraTx era, ExtendedUTxO era, EraUTxO era, ScriptsNeeded era ~ AlonzoScriptsNeeded era, Script era ~ AlonzoScript era, EraPlutusContext 'PlutusV1 era) => PParams era -> Tx era -> UTxO era -> EpochInfo (Either Text) -> SystemStart -> Array Language CostModel -> Either (TranslationError (EraCrypto era)) (RedeemerReport era)
type RedeemerReport era = Map RdmrPtr (Either (TransactionScriptFailure era) ExUnits)

-- | Evaluate the execution budgets needed for all the redeemers in a given
--   transaction. If a redeemer is invalid, a failure is returned instead.
--   
--   The execution budgets in the supplied transaction are completely
--   ignored. The results of
--   <a>evaluateTransactionExecutionUnitsWithLogs</a> are intended to
--   replace them.
evalTxExUnitsWithLogs :: forall era. (AlonzoEraTx era, ExtendedUTxO era, EraUTxO era, ScriptsNeeded era ~ AlonzoScriptsNeeded era, Script era ~ AlonzoScript era, EraPlutusContext 'PlutusV1 era) => PParams era -> Tx era -> UTxO era -> EpochInfo (Either Text) -> SystemStart -> Either (TranslationError (EraCrypto era)) (RedeemerReportWithLogs era)

-- | Evaluate the execution budgets needed for all the redeemers in a given
--   transaction. If a redeemer is invalid, a failure is returned instead.
--   
--   The execution budgets in the supplied transaction are completely
--   ignored. The results of
--   <a>evaluateTransactionExecutionUnitsWithLogs</a> are intended to
--   replace them.

-- | <i>Deprecated: In favor of <a>evalTxExUnitsWithLogs</a></i>
evaluateTransactionExecutionUnitsWithLogs :: forall era. (AlonzoEraTx era, ExtendedUTxO era, EraUTxO era, ScriptsNeeded era ~ AlonzoScriptsNeeded era, Script era ~ AlonzoScript era, EraPlutusContext 'PlutusV1 era) => PParams era -> Tx era -> UTxO era -> EpochInfo (Either Text) -> SystemStart -> Array Language CostModel -> Either (TranslationError (EraCrypto era)) (RedeemerReportWithLogs era)
type RedeemerReportWithLogs era = Map RdmrPtr (Either (TransactionScriptFailure era) ([Text], ExUnits))

-- | Script failures that can be returned by
--   <a>evaluateTransactionExecutionUnits</a>.
data TransactionScriptFailure era

-- | A redeemer was supplied that does not point to a valid plutus
--   evaluation site in the given transaction.
RedeemerNotNeeded :: !RdmrPtr -> !ScriptHash (EraCrypto era) -> TransactionScriptFailure era

-- | A redeemer was supplied which points to a script hash which we cannot
--   connect to a Plutus script.
RedeemerPointsToUnknownScriptHash :: !RdmrPtr -> TransactionScriptFailure era

-- | Missing redeemer. The first parameter is the redeemer pointer which
--   cannot be resolved, and the second parameter is the map of pointers
--   which can be resolved.
MissingScript :: !RdmrPtr -> !Map RdmrPtr (ScriptPurpose era, Maybe Plutus, ScriptHash (EraCrypto era)) -> TransactionScriptFailure era

-- | Missing datum.
MissingDatum :: !DataHash (EraCrypto era) -> TransactionScriptFailure era

-- | Plutus evaluation error, for any version
ValidationFailure :: ValidationFailed -> TransactionScriptFailure era

-- | A redeemer points to a transaction input which is not present in the
--   current UTxO.
UnknownTxIn :: !TxIn (EraCrypto era) -> TransactionScriptFailure era

-- | A redeemer points to a transaction input which is not plutus locked.
InvalidTxIn :: !TxIn (EraCrypto era) -> TransactionScriptFailure era

-- | The execution budget that was calculated by the Plutus evaluator is
--   out of bounds.
IncompatibleBudget :: !ExBudget -> TransactionScriptFailure era

-- | There was no cost model for a given version of Plutus in the ledger
--   state
NoCostModelInLedgerState :: !Language -> TransactionScriptFailure era
data ValidationFailed
[ValidationFailedV1] :: !EvaluationError -> ![Text] -> PlutusDebugLang 'PlutusV1 -> ValidationFailed
[ValidationFailedV2] :: !EvaluationError -> ![Text] -> PlutusDebugLang 'PlutusV2 -> ValidationFailed
[ValidationFailedV3] :: !EvaluationError -> ![Text] -> PlutusDebugLang 'PlutusV3 -> ValidationFailed


-- | This module provides a library interface for working with types that
--   will allow a user to interact with Cardano ledger.
--   
--   It is intended to be the complete API covering everything but without
--   exposing constructors that reveal any lower level types.
--   
--   In the interest of simplicity it glosses over some details of the
--   system. Most tools should be able to work just using this interface,
--   however you can go deeper and experiment with internal modules if
--   necessary, such as <a>Cardano.Ledger.Core</a>,
--   <a>Cardano.Ledger.Shelley</a>, <a>Cardano.Ledger.Babbage</a>, etc.
module Cardano.Ledger.Api

module Cardano.Ledger.Api.UTxO
newtype () => UTxO era
UTxO :: Map (TxIn (EraCrypto era)) (TxOut era) -> UTxO era
[unUTxO] :: UTxO era -> Map (TxIn (EraCrypto era)) (TxOut era)
class EraTx era => EraUTxO era where {
    type family ScriptsNeeded era = (r :: Type) | r -> era;
}
getConsumedValue :: EraUTxO era => PParams era -> (Credential 'Staking (EraCrypto era) -> Maybe Coin) -> (Credential 'DRepRole (EraCrypto era) -> Maybe Coin) -> UTxO era -> TxBody era -> Value era
getProducedValue :: EraUTxO era => PParams era -> (KeyHash 'StakePool (EraCrypto era) -> Bool) -> TxBody era -> Value era
getScriptsProvided :: EraUTxO era => UTxO era -> Tx era -> ScriptsProvided era
getScriptsNeeded :: EraUTxO era => UTxO era -> TxBody era -> ScriptsNeeded era
getScriptsHashesNeeded :: EraUTxO era => ScriptsNeeded era -> Set (ScriptHash (EraCrypto era))
